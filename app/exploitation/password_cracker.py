#!/usr/bin/env python3
# app/exploitation/password_cracker.py - Password Cracking Tools

import sys
import os
import subprocess
import time
import hashlib
import itertools
import string
from datetime import datetime

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, BASE_DIR)

from config import C_OK, C_WARN, C_ERR, C_RESET, C_INFO, C_TITLE, REPORTS_DIR
from utils import Logger, pause, clear_screen, InputValidator, CommandRunner, ReportWriter

class PasswordCracker:
    def __init__(self):
        self.reports_dir = os.path.join(REPORTS_DIR, 'exploitation', 'password_cracking')
        os.makedirs(self.reports_dir, exist_ok=True)
    
    def run(self):
        """Main password cracker menu"""
        while True:
            clear_screen()
            print(f"\n{C_TITLE}╔══════════════════════════════════════════╗")
            print(f"║        PASSWORD CRACKER                  ║")
            print(f"╚══════════════════════════════════════════╝{C_RESET}\n")
            
            print(f"{C_INFO}  [1]  Hash Identifier{C_RESET}")
            print(f"{C_INFO}  [2]  Hash Cracker (Wordlist){C_RESET}")
            print(f"{C_INFO}  [3]  Hash Cracker (Brute Force){C_RESET}")
            print(f"{C_INFO}  [4]  John The Ripper{C_RESET}")
            print(f"{C_INFO}  [5]  Hashcat{C_RESET}")
            print(f"{C_INFO}  [6]  Hydra (Online Cracking){C_RESET}")
            print(f"{C_INFO}  [7]  Generate Wordlist{C_RESET}")
            print(f"{C_INFO}  [8]  Hash Generator{C_RESET}")
            print(f"\n{C_WARN}  [0]  Back{C_RESET}\n")
            
            choice = InputValidator.get_choice()
            
            if choice == '0':
                return
            elif choice == '1':
                self.hash_identifier()
            elif choice == '2':
                self.hash_cracker_wordlist()
            elif choice == '3':
                self.hash_cracker_bruteforce()
            elif choice == '4':
                self.john_the_ripper()
            elif choice == '5':
                self.hashcat()
            elif choice == '6':
                self.hydra()
            elif choice == '7':
                self.generate_wordlist()
            elif choice == '8':
                self.hash_generator()
            else:
                Logger.error("Invalid choice!")
                time.sleep(1)
    
    def hash_identifier(self):
        """Identify hash type"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HASH IDENTIFIER ═══{C_RESET}\n")
        
        hash_value = input(f"{C_INFO}Enter hash: {C_RESET}").strip()
        
        if not hash_value:
            Logger.error("Hash required!")
            pause()
            return
        
        hash_len = len(hash_value)
        
        print(f"\n{C_INFO}Hash Analysis:{C_RESET}")
        print(f"Length: {hash_len} characters\n")
        
        # Identify based on length and format
        possible_types = []
        
        if hash_len == 32:
            possible_types.extend([
                "MD5",
                "MD4",
                "NTLM",
                "LM"
            ])
        elif hash_len == 40:
            possible_types.extend([
                "SHA-1",
                "MySQL5 (old)",
            ])
        elif hash_len == 64:
            possible_types.extend([
                "SHA-256",
                "SHA3-256",
            ])
        elif hash_len == 128:
            possible_types.extend([
                "SHA-512",
                "SHA3-512",
            ])
        elif hash_len == 56:
            possible_types.append("SHA-224")
        elif hash_len == 96:
            possible_types.append("SHA-384")
        
        # Check for specific formats
        if hash_value.startswith('$1$'):
            possible_types.append("MD5 (Unix)")
        elif hash_value.startswith('$2a$') or hash_value.startswith('$2b$'):
            possible_types.append("bcrypt")
        elif hash_value.startswith('$5$'):
            possible_types.append("SHA-256 (Unix)")
        elif hash_value.startswith('$6$'):
            possible_types.append("SHA-512 (Unix)")
        elif hash_value.startswith('$apr1$'):
            possible_types.append("Apache MD5")
        elif ':' in hash_value:
            possible_types.append("Possible salted hash")
        
        if possible_types:
            Logger.success("Possible hash types:")
            for hash_type in possible_types:
                print(f"  • {hash_type}")
        else:
            Logger.warning("Unknown hash type")
        
        # Save result
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"hash_identify_{timestamp}.txt")
        
        content = ReportWriter.create_report_header("Hash Identification", hash_value)
        content += f"Length: {hash_len}\n\n"
        content += "Possible Types:\n"
        for hash_type in possible_types:
            content += f"  • {hash_type}\n"
        
        with open(report_file, 'w') as f:
            f.write(content)
        
        Logger.info(f"Report saved: {report_file}")
        
        pause()
    
    def hash_cracker_wordlist(self):
        """Crack hash using wordlist"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HASH CRACKER (WORDLIST) ═══{C_RESET}\n")
        
        hash_value = input(f"{C_INFO}Enter hash: {C_RESET}").strip()
        
        if not hash_value:
            Logger.error("Hash required!")
            pause()
            return
        
        print(f"\n{C_INFO}Hash Types:{C_RESET}")
        print(f"  [1] MD5")
        print(f"  [2] SHA-1")
        print(f"  [3] SHA-256")
        print(f"  [4] SHA-512\n")
        
        choice = input(f"{C_INFO}Select hash type [1-4]: {C_RESET}").strip()
        
        hash_types = {
            '1': ('md5', hashlib.md5),
            '2': ('sha1', hashlib.sha1),
            '3': ('sha256', hashlib.sha256),
            '4': ('sha512', hashlib.sha512),
        }
        
        if choice not in hash_types:
            Logger.error("Invalid choice!")
            pause()
            return
        
        hash_name, hash_func = hash_types[choice]
        
        # Wordlist
        wordlist_path = input(f"{C_INFO}Wordlist path [/usr/share/wordlists/rockyou.txt]: {C_RESET}").strip()
        if not wordlist_path:
            wordlist_path = "/usr/share/wordlists/rockyou.txt"
        
        if not os.path.exists(wordlist_path):
            Logger.error(f"Wordlist not found: {wordlist_path}")
            pause()
            return
        
        Logger.info(f"Hash: {hash_value}")
        Logger.info(f"Type: {hash_name}")
        Logger.info(f"Wordlist: {wordlist_path}")
        Logger.warning("Starting crack... This may take a while!")
        
        pause("Press Enter to start...")
        
        start_time = time.time()
        found = False
        tested = 0
        
        try:
            with open(wordlist_path, 'r', encoding='latin-1') as f:
                for line in f:
                    password = line.strip()
                    tested += 1
                    
                    # Calculate hash
                    calculated_hash = hash_func(password.encode()).hexdigest()
                    
                    if calculated_hash == hash_value.lower():
                        found = True
                        elapsed = time.time() - start_time
                        
                        Logger.success(f"PASSWORD FOUND: {password}")
                        Logger.info(f"Tested: {tested} passwords")
                        Logger.info(f"Time: {elapsed:.2f} seconds")
                        
                        # Save result
                        timestamp = ReportWriter.get_timestamp()
                        report_file = os.path.join(self.reports_dir, f"cracked_{timestamp}.txt")
                        
                        content = ReportWriter.create_report_header("Hash Cracked", hash_value)
                        content += f"Hash Type: {hash_name}\n"
                        content += f"Password: {password}\n"
                        content += f"Wordlist: {wordlist_path}\n"
                        content += f"Tested: {tested} passwords\n"
                        content += f"Time: {elapsed:.2f} seconds\n"
                        
                        with open(report_file, 'w') as rf:
                            rf.write(content)
                        
                        Logger.info(f"Report saved: {report_file}")
                        break
                    
                    if tested % 10000 == 0:
                        print(f"Tested: {tested}...", end='\r')
            
            if not found:
                Logger.warning("Password not found in wordlist")
                Logger.info(f"Tested: {tested} passwords")
        
        except KeyboardInterrupt:
            Logger.warning("\nCracking interrupted!")
            Logger.info(f"Tested: {tested} passwords")
        except Exception as e:
            Logger.error(f"Error: {e}")
        
        pause()
    
    def hash_cracker_bruteforce(self):
        """Crack hash using brute force"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HASH CRACKER (BRUTE FORCE) ═══{C_RESET}\n")
        
        hash_value = input(f"{C_INFO}Enter hash: {C_RESET}").strip()
        
        if not hash_value:
            Logger.error("Hash required!")
            pause()
            return
        
        print(f"\n{C_INFO}Hash Types:{C_RESET}")
        print(f"  [1] MD5")
        print(f"  [2] SHA-1")
        print(f"  [3] SHA-256\n")
        
        choice = input(f"{C_INFO}Select hash type [1-3]: {C_RESET}").strip()
        
        hash_types = {
            '1': ('md5', hashlib.md5),
            '2': ('sha1', hashlib.sha1),
            '3': ('sha256', hashlib.sha256),
        }
        
        if choice not in hash_types:
            Logger.error("Invalid choice!")
            pause()
            return
        
        hash_name, hash_func = hash_types[choice]
        
        # Brute force parameters
        min_len = int(input(f"{C_INFO}Minimum length [4]: {C_RESET}").strip() or "4")
        max_len = int(input(f"{C_INFO}Maximum length [6]: {C_RESET}").strip() or "6")
        
        print(f"\n{C_INFO}Character Sets:{C_RESET}")
        print(f"  [1] Lowercase (a-z)")
        print(f"  [2] Lowercase + Uppercase")
        print(f"  [3] Lowercase + Digits")
        print(f"  [4] All (lowercase + uppercase + digits)\n")
        
        charset_choice = input(f"{C_INFO}Select charset [1-4]: {C_RESET}").strip()
        
        charsets = {
            '1': string.ascii_lowercase,
            '2': string.ascii_lowercase + string.ascii_uppercase,
            '3': string.ascii_lowercase + string.digits,
            '4': string.ascii_lowercase + string.ascii_uppercase + string.digits,
        }
        
        charset = charsets.get(charset_choice, string.ascii_lowercase)
        
        Logger.info(f"Hash: {hash_value}")
        Logger.info(f"Type: {hash_name}")
        Logger.info(f"Length: {min_len}-{max_len}")
        Logger.info(f"Charset: {len(charset)} characters")
        Logger.warning("This may take a VERY long time!")
        
        pause("Press Enter to start...")
        
        start_time = time.time()
        found = False
        tested = 0
        
        try:
            for length in range(min_len, max_len + 1):
                Logger.info(f"Testing length: {length}")
                
                for attempt in itertools.product(charset, repeat=length):
                    password = ''.join(attempt)
                    tested += 1
                    
                    calculated_hash = hash_func(password.encode()).hexdigest()
                    
                    if calculated_hash == hash_value.lower():
                        found = True
                        elapsed = time.time() - start_time
                        
                        Logger.success(f"PASSWORD FOUND: {password}")
                        Logger.info(f"Tested: {tested} combinations")
                        Logger.info(f"Time: {elapsed:.2f} seconds")
                        
                        # Save result
                        timestamp = ReportWriter.get_timestamp()
                        report_file = os.path.join(self.reports_dir, f"bruteforce_{timestamp}.txt")
                        
                        content = ReportWriter.create_report_header("Brute Force Success", hash_value)
                        content += f"Hash Type: {hash_name}\n"
                        content += f"Password: {password}\n"
                        content += f"Length: {length}\n"
                        content += f"Tested: {tested} combinations\n"
                        content += f"Time: {elapsed:.2f} seconds\n"
                        
                        with open(report_file, 'w') as rf:
                            rf.write(content)
                        
                        Logger.info(f"Report saved: {report_file}")
                        break
                    
                    if tested % 1000 == 0:
                        print(f"Tested: {tested}...", end='\r')
                
                if found:
                    break
            
            if not found:
                Logger.warning("Password not found")
                Logger.info(f"Tested: {tested} combinations")
        
        except KeyboardInterrupt:
            Logger.warning("\nBrute force interrupted!")
            Logger.info(f"Tested: {tested} combinations")
        except Exception as e:
            Logger.error(f"Error: {e}")
        
        pause()
    
    def john_the_ripper(self):
        """John The Ripper integration"""
        clear_screen()
        print(f"\n{C_TITLE}═══ JOHN THE RIPPER ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('john'):
            Logger.error("John The Ripper not installed!")
            Logger.info("Install: sudo apt install john")
            pause()
            return
        
        print(f"{C_INFO}Options:{C_RESET}")
        print(f"  [1] Crack hash file")
        print(f"  [2] Show cracked passwords")
        print(f"  [3] Incremental mode")
        print(f"  [4] Wordlist mode\n")
        
        choice = input(f"{C_INFO}Select option [1-4]: {C_RESET}").strip()
        
        if choice == '1':
            hash_file = input(f"{C_INFO}Enter hash file path: {C_RESET}").strip()
            
            if not hash_file or not os.path.exists(hash_file):
                Logger.error("Invalid file path!")
                pause()
                return
            
            cmd = f"john {hash_file}"
            Logger.info("Starting John The Ripper...")
            os.system(cmd)
            
        elif choice == '2':
            hash_file = input(f"{C_INFO}Enter hash file path: {C_RESET}").strip()
            
            if hash_file and os.path.exists(hash_file):
                cmd = f"john --show {hash_file}"
                os.system(cmd)
            else:
                Logger.error("Invalid file path!")
        
        elif choice == '3':
            hash_file = input(f"{C_INFO}Enter hash file path: {C_RESET}").strip()
            
            if not hash_file or not os.path.exists(hash_file):
                Logger.error("Invalid file path!")
                pause()
                return
            
            cmd = f"john --incremental {hash_file}"
            Logger.info("Starting incremental mode...")
            os.system(cmd)
        
        elif choice == '4':
            hash_file = input(f"{C_INFO}Enter hash file path: {C_RESET}").strip()
            wordlist = input(f"{C_INFO}Enter wordlist path: {C_RESET}").strip()
            
            if not hash_file or not os.path.exists(hash_file):
                Logger.error("Invalid hash file!")
                pause()
                return
            
            if not wordlist or not os.path.exists(wordlist):
                Logger.error("Invalid wordlist!")
                pause()
                return
            
            cmd = f"john --wordlist={wordlist} {hash_file}"
            Logger.info("Starting wordlist mode...")
            os.system(cmd)
        
        else:
            Logger.error("Invalid choice!")
        
        pause()
    
    def hashcat(self):
        """Hashcat integration"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HASHCAT ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('hashcat'):
            Logger.error("Hashcat not installed!")
            Logger.info("Install: sudo apt install hashcat")
            pause()
            return
        
        print(f"{C_INFO}Common Hash Types:{C_RESET}")
        print(f"  0     - MD5")
        print(f"  100   - SHA-1")
        print(f"  1000  - NTLM")
        print(f"  1400  - SHA-256")
        print(f"  1800  - SHA-512 (Unix)")
        print(f"  3200  - bcrypt\n")
        
        hash_type = input(f"{C_INFO}Enter hash type: {C_RESET}").strip()
        hash_file = input(f"{C_INFO}Enter hash file path: {C_RESET}").strip()
        wordlist = input(f"{C_INFO}Enter wordlist path: {C_RESET}").strip()
        
        if not hash_file or not os.path.exists(hash_file):
            Logger.error("Invalid hash file!")
            pause()
            return
        
        if not wordlist or not os.path.exists(wordlist):
            Logger.error("Invalid wordlist!")
            pause()
            return
        
        cmd = f"hashcat -m {hash_type} -a 0 {hash_file} {wordlist}"
        
        Logger.info(f"Command: {cmd}")
        pause("Press Enter to start...")
        
        os.system(cmd)
        pause()
    
    def hydra(self):
        """Hydra online password cracking"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HYDRA (ONLINE CRACKING) ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('hydra'):
            Logger.error("Hydra not installed!")
            Logger.info("Install: sudo apt install hydra")
            pause()
            return
        
        print(f"{C_INFO}Services:{C_RESET}")
        print(f"  [1] SSH")
        print(f"  [2] FTP")
        print(f"  [3] HTTP-POST")
        print(f"  [4] MySQL")
        print(f"  [5] RDP\n")
        
        choice = input(f"{C_INFO}Select service [1-5]: {C_RESET}").strip()
        
        services = {
            '1': 'ssh',
            '2': 'ftp',
            '3': 'http-post-form',
            '4': 'mysql',
            '5': 'rdp',
        }
        
        service = services.get(choice)
        if not service:
            Logger.error("Invalid choice!")
            pause()
            return
        
        target = input(f"{C_INFO}Enter target IP: {C_RESET}").strip()
        username = input(f"{C_INFO}Enter username (or user file): {C_RESET}").strip()
        wordlist = input(f"{C_INFO}Enter password wordlist: {C_RESET}").strip()
        
        if not target or not username or not wordlist:
            Logger.error("All fields required!")
            pause()
            return
        
        # Build command
        if os.path.isfile(username):
            cmd = f"hydra -L {username} -P {wordlist} {service}://{target}"
        else:
            cmd = f"hydra -l {username} -P {wordlist} {service}://{target}"
        
        Logger.info(f"Command: {cmd}")
        pause("Press Enter to start...")
        
        # Run and save output
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"hydra_{timestamp}.txt")
        
        os.system(f"{cmd} | tee {report_file}")
        
        Logger.success(f"Results saved: {report_file}")
        pause()
    
    def generate_wordlist(self):
        """Generate custom wordlist"""
        clear_screen()
        print(f"\n{C_TITLE}═══ WORDLIST GENERATOR ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('crunch'):
            Logger.warning("Crunch not installed (optional)")
            Logger.info("Install: sudo apt install crunch")
        
        print(f"{C_INFO}Options:{C_RESET}")
        print(f"  [1] Use Crunch")
        print(f"  [2] Simple generator\n")
        
        choice = input(f"{C_INFO}Select option [1-2]: {C_RESET}").strip()
        
        if choice == '1' and CommandRunner.check_tool('crunch'):
            min_len = input(f"{C_INFO}Minimum length: {C_RESET}").strip()
            max_len = input(f"{C_INFO}Maximum length: {C_RESET}").strip()
            charset = input(f"{C_INFO}Charset (leave empty for default): {C_RESET}").strip()
            
            output = os.path.join(self.reports_dir, "wordlist.txt")
            
            cmd = f"crunch {min_len} {max_len}"
            if charset:
                cmd += f" {charset}"
            cmd += f" -o {output}"
            
            Logger.info("Generating wordlist...")
            os.system(cmd)
            Logger.success(f"Wordlist saved: {output}")
        
        elif choice == '2':
            # Simple generator
            base_word = input(f"{C_INFO}Enter base word: {C_RESET}").strip()
            
            if not base_word:
                Logger.error("Base word required!")
                pause()
                return
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output = os.path.join(self.reports_dir, f"wordlist_{timestamp}.txt")
            
            # Generate variations
            variations = [
                base_word,
                base_word.upper(),
                base_word.capitalize(),
                base_word + "123",
                base_word + "!",
                base_word + "2024",
                "123" + base_word,
            ]
            
            # Add years
            for year in range(2020, 2026):
                variations.append(base_word + str(year))
            
            # Add numbers
            for num in range(10):
                variations.append(base_word + str(num))
            
            with open(output, 'w') as f:
                for word in variations:
                    f.write(word + '\n')
            
            Logger.success(f"Generated {len(variations)} variations")
            Logger.info(f"Saved: {output}")
        
        else:
            Logger.error("Invalid choice!")
        
        pause()
    
    def hash_generator(self):
        """Generate hashes"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HASH GENERATOR ═══{C_RESET}\n")
        
        text = input(f"{C_INFO}Enter text to hash: {C_RESET}").strip()
        
        if not text:
            Logger.error("Text required!")
            pause()
            return
        
        print(f"\n{C_OK}Generated Hashes:{C_RESET}\n")
        
        hashes = {
            'MD5': hashlib.md5(text.encode()).hexdigest(),
            'SHA-1': hashlib.sha1(text.encode()).hexdigest(),
            'SHA-224': hashlib.sha224(text.encode()).hexdigest(),
            'SHA-256': hashlib.sha256(text.encode()).hexdigest(),
            'SHA-384': hashlib.sha384(text.encode()).hexdigest(),
            'SHA-512': hashlib.sha512(text.encode()).hexdigest(),
        }
        
        for name, hash_value in hashes.items():
            print(f"{C_INFO}{name:12}{C_RESET} {hash_value}")
        
        # Save hashes
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"hashes_{timestamp}.txt")
        
        content = ReportWriter.create_report_header("Generated Hashes", text)
        
        for name, hash_value in hashes.items():
            content += f"{name:12} {hash_value}\n"
        
        with open(report_file, 'w') as f:
            f.write(content)
        
        Logger.info(f"\nSaved: {report_file}")
        
        pause()

if __name__ == "__main__":
    cracker = PasswordCracker()
    cracker.run()