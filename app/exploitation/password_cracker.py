#!/usr/bin/env python3
# app/exploitation/password_cracker.py - Password Cracking Tools

import sys
import os
import subprocess
import time
import hashlib
import itertools
import string
from datetime import datetime

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, BASE_DIR)

from config import C_OK, C_WARN, C_ERR, C_RESET, C_INFO, C_TITLE, REPORTS_DIR
from utils import Logger, pause, clear_screen, InputValidator, CommandRunner, ReportWriter

class PasswordCracker:
    def __init__(self):
        self.reports_dir = os.path.join(REPORTS_DIR, 'exploitation', 'password_cracking')
        os.makedirs(self.reports_dir, exist_ok=True)
    
    def run(self):
        """Main password cracker menu"""
        while True:
            clear_screen()
            print(f"\n{C_TITLE}╔══════════════════════════════════════════╗")
            print(f"║        PASSWORD CRACKER                  ║")
            print(f"╚══════════════════════════════════════════╝{C_RESET}\n")
            
            print(f"{C_INFO}  [1]  Hash Identifier{C_RESET}")
            print(f"{C_INFO}  [2]  Hash Cracker (Wordlist){C_RESET}")
            print(f"{C_INFO}  [3]  Hash Cracker (Brute Force){C_RESET}")
            print(f"{C_INFO}  [4]  John The Ripper{C_RESET}")
            print(f"{C_INFO}  [5]  Hashcat{C_RESET}")
            print(f"{C_INFO}  [6]  Hydra (Online Cracking){C_RESET}")
            print(f"{C_INFO}  [7]  Generate Wordlist{C_RESET}")
            print(f"{C_INFO}  [8]  Hash Generator{C_RESET}")
            print(f"\n{C_WARN}  [0]  Back{C_RESET}\n")
            
            choice = InputValidator.get_choice()
            
            if choice == '0':
                return
            elif choice == '1':
                self.hash_identifier()
            elif choice == '2':
                self.hash_cracker_wordlist()
            elif choice == '3':
                self.hash_cracker_bruteforce()
            elif choice == '4':
                self.john_the_ripper()
            elif choice == '5':
                self.hashcat()
            elif choice == '6':
                self.hydra()
            elif choice == '7':
                self.generate_wordlist()
            elif choice == '8':
                self.hash_generator()
            else:
                Logger.error("Invalid choice!")
                time.sleep(1)
    
    def hash_identifier(self):
        """Identify hash type"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HASH IDENTIFIER ═══{C_RESET}\n")
        
        hash_value = input(f"{C_INFO}Enter hash: {C_RESET}").strip()
        
        if not hash_value:
            Logger.error("Hash required!")
            pause()
            return
        
        hash_len = len(hash_value)
        
        print(f"\n{C_INFO}Hash Analysis:{C_RESET}")
        print(f"Length: {hash_len} characters\n")
        
        # Identify based on length and format
        possible_types = []
        
        if hash_len == 32:
            possible_types.extend([
                "MD5",
                "MD4",
                "NTLM",
                "LM"
            ])
        elif hash_len == 40:
            possible_types.extend([
                "SHA-1",
                "MySQL5 (old)",
            ])
        elif hash_len == 64:
            possible_types.extend([
                "SHA-256",
                "SHA3-256",
            ])
        elif hash_len == 128:
            possible_types.extend([
                "SHA-512",
                "SHA3-512",
            ])
        elif hash_len == 56:
            possible_types.append("SHA-224")
        elif hash_len == 96:
            possible_types.append("SHA-384")
        
        # Check for specific formats
        if hash_value.startswith('$1$'):
            possible_types.append("MD5 (Unix)")
        elif hash_value.startswith('$2a$') or hash_value.startswith('$2b$'):
            possible_types.append("bcrypt")
        elif hash_value.startswith('$5$'):
            possible_types.append("SHA-256 (Unix)")
        elif hash_value.startswith('$6$'):
            possible_types.append("SHA-512 (Unix)")
        elif hash_value.startswith('$apr1$'):
            possible_types.append("Apache MD5")
        elif ':' in hash_value:
            possible_types.append("Possible salted hash")
        
        if possible_types:
            Logger.success("Possible hash types:")
            for hash_type in possible_types:
                print(f"  • {hash_type}")
        else:
            Logger.warning("Unknown hash type")
        
        # Save result
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"hash_identify_{timestamp}.txt")
        
        content = ReportWriter.create_report_header("Hash Identification", hash_value)
        content += f"Length: {hash_len}\n\n"
        content += "Possible Types:\n"
        for hash_type in possible_types:
            content += f"  • {hash_type}\n"
        
        with open(report_file, 'w') as f:
            f.write(content)
        
        Logger.info(f"Report saved: {report_file}")
        
        pause()
    
    def hash_cracker_wordlist(self):
        """Crack hash using wordlist"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HASH CRACKER (WORDLIST) ═══{C_RESET}\n")
        
        hash_value = input(f"{C_INFO}Enter hash: {C_RESET}").strip()
        
        if not hash_value:
            Logger.error("Hash required!")
            pause()
            return
        
        print(f"\n{C_INFO}Hash Types:{C_RESET}")
        print(f"  [1] MD5")
        print(f"  [2] SHA-1")
        print(f"  [3] SHA-256")
        print(f"  [4] SHA-512\n")
        
        choice = input(f"{C_INFO}Select hash type [1-4]: {C_RESET}").strip()
        
        hash_types = {
            '1': ('md5', hashlib.md5),
            '2': ('sha1', hashlib.sha1),
            '3': ('sha256', hashlib.sha256),
            '4': ('sha512', hashlib.sha512),
        }
        
        if choice not in hash_types:
            Logger.error("Invalid choice!")
            pause()
            return
        
        hash_name, hash_func = hash_types[choice]
        
        # Wordlist
        wordlist_path = input(f"{C_INFO}Wordlist path [/usr/share/wordlists/rockyou.txt]: {C_RESET}").strip()
        if not wordlist_path:
            wordlist_path = "/usr/share/wordlists/rockyou.txt"
        
        if not os.path.exists(wordlist_path):
            Logger.error(f"Wordlist not found: {wordlist_path}")
            pause()
            return
        
        Logger.info(f"Hash: {hash_value}")
        Logger.info(f"Type: {hash_name}")
        Logger.info(f"Wordlist: {wordlist_path}")
        Logger.warning("Starting crack... This may take a while!")
        
        pause("Press Enter to start...")
        
        start_time = time.time()
        found = False
        tested = 0
        
        try:
            with open(wordlist_path, 'r', encoding='latin-1') as f:
                for line in f:
                    password = line.strip()
                    tested += 1
                    
                    # Calculate hash
                    calculated_hash = hash_func(password.encode()).hexdigest()
                    
                    if calculated_hash == hash_value.lower():
                        found = True
                        elapsed = time.time() - start_time
                        
                        Logger.success(f"PASSWORD FOUND: {password}")
                        Logger.info(f"Tested: {tested} passwords")
                        Logger.info(f"Time: {elapsed:.2f} seconds")
                        
                        # Save result
                        timestamp = ReportWriter.get_timestamp()
                        report_file = os.path.join(self.reports_dir, f"cracked_{timestamp}.txt")
                        
                        content = ReportWriter.create_report_header("Hash Cracked", hash_value)
                        content += f"Hash Type: {hash_name}\n"
                        content += f"Password: {password}\n"
                        content += f"Wordlist: {wordlist_path}\n"
                        content += f"Tested: {tested} passwords\n"
                        content += f"Time: {elapsed:.2f} seconds\n"
                        
                        with open(report_file, 'w') as rf:
                            rf.write(content)
                        
                        Logger.info(f"Report saved: {report_file}")
                        break
                    
                    if tested % 10000 == 0:
                        print(f"Tested: {tested}...", end='\r')
            
            if not found:
                Logger.warning("Password not found in wordlist")
                Logger.info(f"Tested: {tested} passwords")
        
        except KeyboardInterrupt:
            Logger.warning("\nCracking interrupted!")
            Logger.info(f"Tested: {tested} passwords")
        except Exception as e:
            Logger.error(f"Error: {e}")
        
        pause()
    
    def hash_cracker_bruteforce(self):
        """Crack hash using brute force"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HASH CRACKER (BRUTE FORCE) ═══{C_RESET}\n")
        
        hash_value = input(f"{C_INFO}Enter hash: {C_RESET}").strip()
        
        if not hash_value:
            Logger.error("Hash required!")
            pause()
            return
        
        print(f"\n{C_INFO}Hash Types:{C_RESET}")
        print(f"  [1] MD5")
        print(f"  [2] SHA-1")
        print(f"  [3] SHA-256\n")
        
        choice = input(f"{C_INFO}Select hash type [1-3]: {C_RESET}").strip()
        
        hash_types = {
            '1': ('md5', hashlib.md5),
            '2': ('sha1', hashlib.sha1),
            '3': ('sha256', hashlib.sha256),
        }
        
        if choice not in hash_types:
            Logger.error("Invalid choice!")
            pause()
            return
        
        hash_name, hash_func = hash_types[choice]
        
        # Brute force parameters
        min_len = int(input(f"{C_INFO}Minimum length [4]: {C_RESET}").strip() or "4")
        max_len = int(input(f"{C_INFO}Maximum length [6]: {C_RESET}").strip() or "6")
        
        print(f"\n{C_INFO}Character Sets:{C_RESET}")
        print(f"  [1] Lowercase (a-z)")
        print(f"  [2] Lowercase + Uppercase")
        print(f"  [3] Lowercase + Digits")
        print(f"  [4] All (lowercase + uppercase + digits)\n")
        
        charset_choice = input(f"{C_INFO}Select charset [1-4]: {C_RESET}").strip()
        
        charsets = {
            '1': string.ascii_lowercase,
            '2': string.ascii_lowercase + string.ascii_uppercase,
            '3': string.ascii_lowercase + string.digits,
            '4': string.ascii_lowercase + string.ascii_uppercase + string.digits,
        }
        
        charset = charsets.get(charset_choice, string.ascii_lowercase)
        
        Logger.info(f"Hash: {hash_value}")
        Logger.info(f"Type: {hash_name}")
        Logger.info(f"Length: {min_len}-{max_len}")
        Logger.info(f"Charset: {len(charset)} characters")
        Logger.warning("This may take a VERY long time!")
        
        pause("Press Enter to start...")
        
        start_time = time.time()
        found = False
        tested = 0
        
        try:
            for length in range(min_len, max_len + 1):
                Logger.info(f"Testing length: {length}")
                
                for attempt in itertools.product(charset, repeat=length):
                    password = ''.join(attempt)
                    tested += 1
                    
                    calculated_hash = hash_func(password.encode()).hexdigest()
                    
                    if calculated_hash == hash_value.lower():
                        found = True
                        elapsed = time.time() - start_time
                        
                        Logger.success(f"PASSWORD FOUND: {password}")
                        Logger.info(f"Tested: {tested} combinations")
                        Logger.info(f"Time: {elapsed:.2f} seconds")
                        
                        # Save result
                        timestamp = ReportWriter.get_timestamp()
                        report_file = os.path.join(self.reports_dir, f"bruteforce_{timestamp}.txt")
                        
                        content = ReportWriter.create_report_header("Brute Force Success", hash_value)
                        content += f"Hash Type: {hash_name}\n"
                        content += f"Password: {password}\n"
                        content += f"Length: {length}\n"
                        content += f"Tested: {tested} combinations\n"
                        content += f"Time: {elapsed:.2f} seconds\n"
                        
                        with open(report_file, 'w') as rf:
                            rf.write(content)
                        
                        Logger.info(f"Report saved: {report_file}")
                        break
                    
                    if tested % 1000 == 0:
                        print(f"Tested: {tested}...", end='\r')
                
                if found:
                    break
            
            if not found:
                Logger.warning("Password not found")
                Logger.info(f"Tested: {tested} combinations")
        
        except KeyboardInterrupt:
            Logger.warning("\nBrute force interrupted!")
            Logger.info(f"Tested: {tested} combinations")
        except Exception as e:
            Logger.error(f"Error: {e}")
        
        pause()
    
    def john_the_ripper(self):
        """John The Ripper integration"""
        clear_screen()
        print(f"\n{C_TITLE}═══ JOHN THE RIPPER ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('john'):
            Logger.error("John The Ripper not installed!")
            Logger.info("Install: sudo apt install john")
            pause()
            return
        
        print(f"{C_INFO}Options:{C_RESET}")
        print(f"  [1] Crack hash file")
        print(f"  [2] Show cracked passwords")
        print(f"  [3] Incremental mode")
        print(f"  [4] Wordlist mode\n")
        
        choice = input(f"{C_INFO}Select option [1-4]: {C_RESET}").strip()
        
        if choice == '1':
            hash_file = input(f"{C_INFO}Enter hash file path: {C_RESET}").strip()
            
            if not hash_file or not os.path.exists(hash_file):
                Logger.error("Invalid file path!")
                pause()
                return
            
            cmd = f"john {hash_file}"
            Logger.info("Starting John The Ripper...")
            os.system(cmd)
            
        elif choice == '2':
            hash_file = input(f"{C_INFO}Enter hash file path: {C_RESET}").strip()
            
            if hash_file and os.path.exists(hash_file):
                cmd = f"john --show {hash_file}"
                os.system(cmd)
            else:
                Logger.error("Invalid file path!")
        
        elif choice == '3':
            hash_file = input(f"{C_INFO}Enter hash file path: {C_RESET}").strip()
            
            if not hash_file or not os.path.exists(hash_file):
                Logger.error("Invalid file path!")
                pause()
                return
            
            cmd = f"john --incremental {hash_file}"
            Logger.info("Starting incremental mode...")
            os.system(cmd)
        
        elif choice == '4':
            hash_file = input(f"{C_INFO}Enter hash file path: {C_RESET}").strip()
            wordlist = input(f"{C_INFO}Enter wordlist path: {C_RESET}").strip()
            
            if not hash_file or not os.path.exists(hash_file):
                Logger.error("Invalid hash file!")
                pause()
                return
            
            if not wordlist or not os.path.exists(wordlist):
                Logger.error("Invalid wordlist!")
                pause()
                return
            
            cmd = f"john --wordlist={wordlist} {hash_file}"
            Logger.info("Starting wordlist mode...")
            os.system(cmd)
        
        else:
            Logger.error("Invalid choice!")
        
        pause()
    
    def hashcat(self):
        """Hashcat integration"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HASHCAT ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('hashcat'):
            Logger.error("Hashcat not installed!")
            Logger.info("Install: sudo apt install hashcat")
            pause()
            return
        
        print(f"{C_INFO}Common Hash Types:{C_RESET}")
        print(f"  0     - MD5")
        print(f"  100   - SHA-1")
        print(f"  1000  - NTLM")
        print(f"  1400  - SHA-256")
        print(f"  1800  - SHA-512 (Unix)")
        print(f"  3200  - bcrypt\n")
        
        hash_type = input(f"{C_INFO}Enter hash type: {C_RESET}").strip()
        hash_file = input(f"{C_INFO}Enter hash file path: {C_RESET}").strip()
        wordlist = input(f"{C_INFO}Enter wordlist path: {C_RESET}").strip()
        
        if not hash_file or not os.path.exists(hash_file):
            Logger.error("Invalid hash file!")
            pause()
            return
        
        if not wordlist or not os.path.exists(wordlist):
            Logger.error("Invalid wordlist!")
            pause()
            return
        
        cmd = f"hashcat -m {hash_type} -a 0 {hash_file} {wordlist}"
        
        Logger.info(f"Command: {cmd}")
        pause("Press Enter to start...")
        
        os.system(cmd)
        pause()
    
    def hydra(self):
        """Hydra online password cracking"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HYDRA (ONLINE CRACKING) ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('hydra'):
            Logger.error("Hydra not installed!")
            Logger.info("Install: sudo apt install hydra")
            pause()
            return
        
        print(f"{C_INFO}Services:{C_RESET}")
        print(f"  [1] SSH")
        print(f"  [2] FTP")
        print(f"  [3] HTTP-POST")
        print(f"  [4] MySQL")
        print(f"  [5] RDP\n")
        
        choice = input(f"{C_INFO}Select service [1-5]: {C_RESET}").strip()
        
        services = {
            '1': 'ssh',
            '2': 'ftp',
            '3': 'http-post-form',
            '4': 'mysql',
            '5': 'rdp',
        }
        
        service = services.get(choice)
        if not service:
            Logger.error("Invalid choice!")
            pause()
            return
        
        target = input(f"{C_INFO}Enter target IP: {C_RESET}").strip()
        username = input(f"{C_INFO}Enter username (or user file): {C_RESET}").strip()
        wordlist = input(f"{C_INFO}Enter password wordlist: {C_RESET}").strip()
        
        if not target or not username or not wordlist:
            Logger.error("All fields required!")
            pause()
            return
        
        # Build command
        if os.path.isfile(username):
            cmd = f"hydra -L {username} -P {wordlist} {service}://{target} -t 4"
        else:
            cmd = f"hydra -l {username} -P {wordlist} {service}://{target} -t 4"
        
        Logger.info(f"Command: {cmd}")
        pause("Press Enter to start...")
        
        # Run and save output
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"hydra_{timestamp}.txt")
        
        os.system(f"{cmd} | tee {report_file}")
        
        Logger.success(f"Results saved: {report_file}")
        pause()
    
    def generate_wordlist(self):
        """Generate custom wordlist - Enhanced with more tools and options"""
        clear_screen()
        print(f"\n{C_TITLE}═══ WORDLIST GENERATOR ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('crunch'):
            Logger.warning("Crunch not installed (recommended for advanced generation)")
            Logger.info("Install: sudo apt install crunch")
        
        if not CommandRunner.check_tool('cupp'):
            Logger.warning("CUPP not installed (great for targeted personal wordlists)")
            Logger.info("Install: git clone https://github.com/Mebus/cupp.git")

        print(f"{C_INFO}Options:{C_RESET}")
        print(f"  [1] Use Crunch (pattern-based brute-force wordlists)")
        print(f"  [2] Use CUPP (targeted personal information wordlist)")
        print(f"  [3] Simple Python generator (mutations & common appendages)")
        print(f"\n{C_WARN}  [0] Back{C_RESET}\n")
        
        # TUZATILGAN QATOR:
        print(f"{C_INFO}Select option [0-4]: {C_RESET}", end='')
        choice = InputValidator.get_choice()
        
        if choice == '0':
            return
        
        elif choice == '1':
            self._crunch_generator()
        
        elif choice == '2':
            self._cupp_generator()
        
        elif choice == '3':
            self._simple_python_generator()
        else:
            Logger.error("Invalid choice!")
            pause()
    
    def _crunch_generator(self):
        """Detailed Crunch wordlist generator with step-by-step options"""
        clear_screen()
        print(f"\n{C_TITLE}═══ CRUNCH GENERATOR ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('crunch'):
            Logger.error("Crunch is not installed!")
            pause()
            return
        
        print(f"{C_INFO}Crunch allows very powerful pattern-based wordlist generation.{C_RESET}\n")
        
        min_len = input(f"{C_INFO}Minimum length [1]: {C_RESET}").strip() or "1"
        max_len = input(f"{C_INFO}Maximum length (leave empty = same as min): {C_RESET}").strip()
        
        if not max_len:
            max_len = min_len
        
        charset = input(f"{C_INFO}Custom charset (e.g. abc123, leave empty for default abcdef...): {C_RESET}").strip()
        
        pattern = input(f"{C_INFO}Pattern (e.g. @@@123 for 3 lowercase + 123, leave empty for full permutation): {C_RESET}").strip()
        
        output_name = input(f"{C_INFO}Output filename [wordlist_crunch.txt]: {C_RESET}").strip()
        if not output_name:
            output_name = "wordlist_crunch.txt"
        
        timestamp = ReportWriter.get_timestamp()
        output = os.path.join(self.reports_dir, f"{output_name}_{timestamp}.txt")
        
        # Build crunch command step by step
        cmd = f"crunch {min_len} {max_len}"
        
        if pattern:
            cmd += f" {pattern}"
        elif charset:
            cmd += f" {charset}"
        
        # Additional useful crunch options
        print(f"\n{C_INFO}Additional options:{C_RESET}")
        print(f"  [1] Add output compression (-z gzip/bzip2/lzma)")
        print(f"  [2] Start from specific string (-s)")
        print(f"  [3] Limit total combinations (-t @,^% for patterns)")
        print(f"  [4] Invert charset (-i)")
        
        extra = input(f"{C_INFO}Select additional options (comma separated, leave empty): {C_RESET}").strip()
        
        if extra:
            for opt in extra.split(','):
                opt = opt.strip()
                if opt == '1':
                    compress = input(f"{C_INFO}Compression type (gzip/bzip2/lzma): {C_RESET}").strip()
                    if compress in ['gzip', 'bzip2', 'lzma']:
                        cmd += f" -z {compress}"
                elif opt == '2':
                    start = input(f"{C_INFO}Start string: {C_RESET}").strip()
                    if start:
                        cmd += f" -s {start}"
                elif opt == '3':
                    limit = input(f"{C_INFO}Pattern limit (e.g. @@@123): {C_RESET}").strip()
                    if limit:
                        cmd += f" -t {limit}"
                elif opt == '4':
                    cmd += " -i"
        
        cmd += f" -o {output}"
        
        Logger.info(f"Crunch command: {cmd}")
        Logger.warning("Generation may take a long time depending on parameters!")
        pause("Press Enter to start...")
        
        os.system(cmd)
        
        if os.path.exists(output) or os.path.exists(output + ".gz"):
            Logger.success(f"Wordlist generated successfully!")
            Logger.info(f"Saved: {output}")
        else:
            Logger.error("Generation failed or file not created.")
        
        pause()
    
    def _cupp_generator(self):
        """Run CUPP for targeted personal wordlist generation"""
        clear_screen()
        print(f"\n{C_TITLE}═══ CUPP - TARGETED WORDLIST ═══{C_RESET}\n")
        
        # Find cupp.py path - common locations
        possible_paths = [
            "./cupp/cupp.py",
            "/usr/share/cupp/cupp.py",
            "/opt/cupp/cupp.py",
            os.path.expanduser("~/tools/cupp/cupp.py"),
            "cupp.py"  # if in PATH
        ]
        
        cupp_path = None
        for path in possible_paths:
            if os.path.isfile(path):
                cupp_path = path
                break
        
        if not cupp_path and not CommandRunner.check_tool('cupp'):
            Logger.error("CUPP not found in common locations!")
            Logger.info("Please install CUPP or ensure cupp.py is in your PATH.")
            pause()
            return
        
        print(f"{C_INFO}CUPP will ask interactive questions about the target person.{C_RESET}")
        print(f"{C_INFO}It generates highly effective personal wordlists based on names, birthdates, pets, etc.{C_RESET}\n")
        
        if cupp_path:
            cmd = f"python3 {cupp_path} -i"
        else:
            cmd = "cupp -i"
        
        timestamp = ReportWriter.get_timestamp()
        output_dir = os.path.join(self.reports_dir, f"cupp_{timestamp}")
        os.makedirs(output_dir, exist_ok=True)
        
        Logger.info("Starting CUPP interactive mode...")
        Logger.info(f"Wordlists will be saved in: {output_dir}")
        
        # Change cwd temporarily so CUPP saves files in our reports dir
        original_cwd = os.getcwd()
        os.chdir(output_dir)
        
        os.system(cmd)
        
        os.chdir(original_cwd)
        
        if any(f.endswith('.txt') for f in os.listdir(output_dir)):
            Logger.success("CUPP wordlist(s) generated successfully!")
            Logger.info(f"Saved in directory: {output_dir}")
        else:
            Logger.warning("No wordlist was generated (possibly cancelled).")
        
        pause()
    
    def _simple_python_generator(self):
        """Enhanced simple Python-based wordlist generator with more mutations"""
        clear_screen()
        print(f"\n{C_TITLE}═══ SIMPLE PYTHON GENERATOR ═══{C_RESET}\n")
        
        base_words_input = input(f"{C_INFO}Enter base word(s) (comma separated): {C_RESET}").strip()
        if not base_words_input:
            Logger.error("At least one base word required!")
            pause()
            return
        
        base_words = [w.strip() for w in base_words_input.split(',') if w.strip()]
        
        print(f"\n{C_INFO}Common appendages to add:{C_RESET}")
        print(f"  • Numbers: 1-99, 123, 1234, years 1980-2030")
        print(f"  • Special chars: !, @, #, $, %, ^")
        print(f"  • Leet transformations (a->@, e->3, etc.)")
        print(f"  • Case variations")
        
        include_numbers = input(f"{C_INFO}Include numbers (y/n) [y]: {C_RESET}").strip().lower() != 'n'
        include_special = input(f"{C_INFO}Include special chars (y/n) [y]: {C_RESET}").strip().lower() != 'n'
        include_leet = input(f"{C_INFO}Include leet variations (y/n) [n]: {C_RESET}").strip().lower() == 'y'
        
        timestamp = ReportWriter.get_timestamp()
        output = os.path.join(self.reports_dir, f"wordlist_simple_{timestamp}.txt")
        
        variations = set()
        
        # Basic case variations
        for word in base_words:
            variations.add(word)
            variations.add(word.upper())
            variations.add(word.capitalize())
            variations.add(word.lower())
            variations.add(word.swapcase())
        
        # Append/prepend numbers
        if include_numbers:
            for word in base_words:
                for num in ['1', '12', '123', '1234', '2023', '2024', '2025', '2026']:
                    variations.add(word + num)
                    variations.add(num + word)
                for year in range(1980, 2031):
                    variations.add(word + str(year))
                    variations.add(str(year) + word)
                for i in range(1, 100):
                    variations.add(word + str(i))
        
        # Special characters
        if include_special:
            specials = ['!', '@', '#', '$', '%', '^']
            for word in base_words:
                for s in specials:
                    variations.add(word + s)
                    variations.add(s + word)
                    variations.add(word + s + '123')
        
        # Leet transformations
        if include_leet:
            leet_map = {'a': '@', 'e': '3', 'i': '1', 'o': '0', 's': '$', 't': '7'}
            for word in base_words:
                leet_word = word.lower()
                for char, repl in leet_map.items():
                    leet_word = leet_word.replace(char, repl)
                variations.add(leet_word)
                variations.add(leet_word.capitalize())
        
        # Write to file
        with open(output, 'w') as f:
            for word in sorted(variations):
                if word:  # skip empty
                    f.write(word + '\n')
        
        Logger.success(f"Generated {len(variations)} unique variations")
        Logger.info(f"Wordlist saved: {output}")
        
        pause()
    

    def hash_generator(self):
        """Generate hashes"""
        clear_screen()
        print(f"\n{C_TITLE}═══ HASH GENERATOR ═══{C_RESET}\n")
        
        text = input(f"{C_INFO}Enter text to hash: {C_RESET}").strip()
        
        if not text:
            Logger.error("Text required!")
            pause()
            return
        
        print(f"\n{C_OK}Generated Hashes:{C_RESET}\n")
        
        hashes = {
            'MD5': hashlib.md5(text.encode()).hexdigest(),
            'SHA-1': hashlib.sha1(text.encode()).hexdigest(),
            'SHA-224': hashlib.sha224(text.encode()).hexdigest(),
            'SHA-256': hashlib.sha256(text.encode()).hexdigest(),
            'SHA-384': hashlib.sha384(text.encode()).hexdigest(),
            'SHA-512': hashlib.sha512(text.encode()).hexdigest(),
        }
        
        for name, hash_value in hashes.items():
            print(f"{C_INFO}{name:12}{C_RESET} {hash_value}")
        
        # Save hashes
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"hashes_{timestamp}.txt")
        
        content = ReportWriter.create_report_header("Generated Hashes", text)
        
        for name, hash_value in hashes.items():
            content += f"{name:12} {hash_value}\n"
        
        with open(report_file, 'w') as f:
            f.write(content)
        
        Logger.info(f"\nSaved: {report_file}")
        
        pause()

if __name__ == "__main__":
    cracker = PasswordCracker()
    cracker.run()