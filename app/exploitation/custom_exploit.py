#!/usr/bin/env python3
# app/exploitation/custom_exploit.py - Custom Exploit Runner

import sys
import os
import subprocess
import time
import json
from datetime import datetime

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, BASE_DIR)

from config import C_OK, C_WARN, C_ERR, C_RESET, C_INFO, C_TITLE, REPORTS_DIR
from utils import Logger, pause, clear_screen, InputValidator, CommandRunner, ReportWriter

class CustomExploitRunner:
    def __init__(self):
        self.reports_dir = os.path.join(REPORTS_DIR, 'exploitation', 'custom_exploits')
        os.makedirs(self.reports_dir, exist_ok=True)
        self.exploits_dir = os.path.join(BASE_DIR, 'exploits')
        os.makedirs(self.exploits_dir, exist_ok=True)
    
    def run(self):
        """Main custom exploit runner menu"""
        while True:
            clear_screen()
            print(f"\n{C_TITLE}╔══════════════════════════════════════════╗")
            print(f"║      CUSTOM EXPLOIT RUNNER               ║")
            print(f"╚══════════════════════════════════════════╝{C_RESET}\n")
            
            print(f"{C_INFO}  [1]  Run Python Exploit{C_RESET}")
            print(f"{C_INFO}  [2]  Run Shell Script Exploit{C_RESET}")
            print(f"{C_INFO}  [3]  Run Ruby Exploit{C_RESET}")
            print(f"{C_INFO}  [4]  List Available Exploits{C_RESET}")
            print(f"{C_INFO}  [5]  Search Exploit-DB{C_RESET}")
            print(f"{C_INFO}  [6]  Download Exploit{C_RESET}")
            print(f"{C_INFO}  [7]  Buffer Overflow Helper{C_RESET}")
            print(f"\n{C_WARN}  [0]  Back{C_RESET}\n")
            
            choice = InputValidator.get_choice()
            
            if choice == '0':
                return
            elif choice == '1':
                self.run_python_exploit()
            elif choice == '2':
                self.run_shell_exploit()
            elif choice == '3':
                self.run_ruby_exploit()
            elif choice == '4':
                self.list_exploits()
            elif choice == '5':
                self.search_exploitdb()
            elif choice == '6':
                self.download_exploit()
            elif choice == '7':
                self.buffer_overflow_helper()
            else:
                Logger.error("Invalid choice!")
                time.sleep(1)
    
    def run_python_exploit(self):
        """Run Python exploit"""
        clear_screen()
        print(f"\n{C_TITLE}═══ RUN PYTHON EXPLOIT ═══{C_RESET}\n")
        
        # Ko'rsatma va misollar
        print(f"{C_INFO}Examples:{C_RESET}")
        print(f"  • {self.exploits_dir}/smb_exploit.py")
        print(f"  • {self.exploits_dir}/web/sql_injection.py")
        print(f"  • /tmp/downloaded_exploit.py")
        print(f"\n{C_WARN}Note: Enter full path to EXPLOIT FILE, not directory!{C_RESET}\n")
        
        exploit_path = input(f"{C_INFO}Enter exploit path: {C_RESET}").strip()
        
        if not exploit_path:
            Logger.error("Exploit path required!")
            pause()
            return
        
        # Check if it's a directory (common mistake)
        if os.path.isdir(exploit_path):
            Logger.error("You entered a directory! Please specify a file.")
            Logger.info(f"Available files in {exploit_path}:")
            try:
                files = [f for f in os.listdir(exploit_path) if f.endswith('.py')]
                for f in files[:10]:  # Show first 10
                    print(f"  • {os.path.join(exploit_path, f)}")
            except:
                pass
            pause()
            return
        
        if not os.path.exists(exploit_path):
            Logger.error(f"File not found: {exploit_path}")
            pause()
            return
        
        if not exploit_path.endswith('.py'):
            Logger.warning("File doesn't have .py extension. Continue anyway? [y/N]")
            if input().strip().lower() != 'y':
                return
        
        # Get target parameters
        print(f"\n{C_INFO}Target Parameters:{C_RESET}")
        print(f"{C_WARN}(Leave empty if exploit doesn't need target){C_RESET}")
        target = input(f"{C_INFO}Enter target IP/URL: {C_RESET}").strip()
        port = input(f"{C_INFO}Enter port (optional): {C_RESET}").strip()
        extra_args = input(f"{C_INFO}Extra arguments (optional): {C_RESET}").strip()
        
        print(f"\n{C_INFO}Configuration:{C_RESET}")
        Logger.info(f"Exploit: {exploit_path}")
        if target:
            Logger.info(f"Target: {target}")
        if port:
            Logger.info(f"Port: {port}")
        if extra_args:
            Logger.info(f"Extra: {extra_args}")
        
        # Build command
        cmd = f"python3 {exploit_path}"
        if target:
            cmd += f" {target}"
        if port:
            cmd += f" {port}"
        if extra_args:
            cmd += f" {extra_args}"
        
        print(f"\n{C_INFO}Command:{C_RESET}")
        print(f"{C_OK}{cmd}{C_RESET}\n")
        
        pause("Press Enter to run exploit...")
        
        # Run and save output
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"python_exploit_{timestamp}.txt")
        
        self._run_and_save(cmd, report_file, exploit_path, target)
        
        pause()
    
    def run_shell_exploit(self):
        """Run shell script exploit"""
        clear_screen()
        print(f"\n{C_TITLE}═══ RUN SHELL EXPLOIT ═══{C_RESET}\n")
        
        # Ko'rsatma va misollar
        print(f"{C_INFO}Examples:{C_RESET}")
        print(f"  • {self.exploits_dir}/linux_priv_esc.sh")
        print(f"  • {self.exploits_dir}/network/port_scan.sh")
        print(f"  • /tmp/exploit.sh")
        print(f"\n{C_WARN}Note: Enter full path to SHELL SCRIPT FILE{C_RESET}\n")
        
        exploit_path = input(f"{C_INFO}Enter exploit path: {C_RESET}").strip()
        
        if not exploit_path:
            Logger.error("Exploit path required!")
            pause()
            return
        
        if os.path.isdir(exploit_path):
            Logger.error("You entered a directory! Please specify a file.")
            pause()
            return
        
        if not os.path.exists(exploit_path):
            Logger.error(f"File not found: {exploit_path}")
            pause()
            return
        
        # Make executable
        try:
            os.chmod(exploit_path, 0o755)
            Logger.success("Made file executable")
        except Exception as e:
            Logger.warning(f"Could not make executable: {e}")
        
        # Get target parameters
        print(f"\n{C_INFO}Target Parameters:{C_RESET}")
        print(f"{C_WARN}(Leave empty if exploit doesn't need target){C_RESET}")
        target = input(f"{C_INFO}Enter target IP/URL: {C_RESET}").strip()
        extra_args = input(f"{C_INFO}Extra arguments (optional): {C_RESET}").strip()
        
        Logger.info(f"Exploit: {exploit_path}")
        if target:
            Logger.info(f"Target: {target}")
        
        # Build command
        cmd = f"bash {exploit_path}"
        if target:
            cmd += f" {target}"
        if extra_args:
            cmd += f" {extra_args}"
        
        print(f"\n{C_INFO}Command:{C_RESET}")
        print(f"{C_OK}{cmd}{C_RESET}\n")
        
        pause("Press Enter to run exploit...")
        
        # Run and save output
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"shell_exploit_{timestamp}.txt")
        
        self._run_and_save(cmd, report_file, exploit_path, target)
        
        pause()
    
    def run_ruby_exploit(self):
        """Run Ruby exploit"""
        clear_screen()
        print(f"\n{C_TITLE}═══ RUN RUBY EXPLOIT ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('ruby'):
            Logger.error("Ruby not installed!")
            Logger.info("Install: sudo apt install ruby")
            pause()
            return
        
        print(f"{C_INFO}Examples:{C_RESET}")
        print(f"  • {self.exploits_dir}/metasploit_module.rb")
        print(f"  • /usr/share/metasploit-framework/modules/exploits/...")
        print()
        
        exploit_path = input(f"{C_INFO}Enter exploit path: {C_RESET}").strip()
        
        if not exploit_path:
            Logger.error("Exploit path required!")
            pause()
            return
        
        if not os.path.exists(exploit_path):
            Logger.error(f"File not found: {exploit_path}")
            pause()
            return
        
        # Get target parameters
        print(f"\n{C_INFO}Target Parameters:{C_RESET}")
        target = input(f"{C_INFO}Enter target IP/URL: {C_RESET}").strip()
        extra_args = input(f"{C_INFO}Extra arguments (optional): {C_RESET}").strip()
        
        Logger.info(f"Exploit: {exploit_path}")
        if target:
            Logger.info(f"Target: {target}")
        
        # Build command
        cmd = f"ruby {exploit_path}"
        if target:
            cmd += f" {target}"
        if extra_args:
            cmd += f" {extra_args}"
        
        print(f"\n{C_INFO}Command:{C_RESET}")
        print(f"{C_OK}{cmd}{C_RESET}\n")
        
        pause("Press Enter to run exploit...")
        
        # Run and save output
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"ruby_exploit_{timestamp}.txt")
        
        self._run_and_save(cmd, report_file, exploit_path, target)
        
        pause()
    
    def list_exploits(self):
        """List available exploits"""
        clear_screen()
        print(f"\n{C_TITLE}═══ AVAILABLE EXPLOITS ═══{C_RESET}\n")
        
        Logger.info(f"Exploits directory: {self.exploits_dir}")
        
        if not os.path.exists(self.exploits_dir):
            Logger.warning(f"Exploits directory not found!")
            Logger.info("Creating exploits directory...")
            os.makedirs(self.exploits_dir, exist_ok=True)
            Logger.success(f"Created: {self.exploits_dir}")
            Logger.info("Add your exploits to this directory")
            pause()
            return
        
        exploits = []
        for root, dirs, files in os.walk(self.exploits_dir):
            for file in files:
                if file.endswith(('.py', '.sh', '.rb', '.pl')):
                    full_path = os.path.join(root, file)
                    rel_path = os.path.relpath(full_path, self.exploits_dir)
                    size = os.path.getsize(full_path)
                    exploits.append((rel_path, full_path, size))
        
        if not exploits:
            Logger.warning("No exploits found!")
            print(f"\n{C_INFO}To add exploits:{C_RESET}")
            print(f"  1. Download from Exploit-DB (option 6)")
            print(f"  2. Copy to: {self.exploits_dir}")
            print(f"  3. Create your own exploits in this directory")
        else:
            Logger.success(f"Found {len(exploits)} exploits:\n")
            for i, (name, path, size) in enumerate(exploits, 1):
                size_kb = size / 1024
                print(f"{C_INFO}  [{i:2d}] {name:<40} ({size_kb:.1f} KB){C_RESET}")
                if i % 20 == 0 and i < len(exploits):
                    pause("Press Enter to continue...")
                    print()
        
        print()
        pause()
    
    def search_exploitdb(self):
        """Search Exploit-DB"""
        clear_screen()
        print(f"\n{C_TITLE}═══ SEARCH EXPLOIT-DB ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('searchsploit'):
            Logger.error("Searchsploit not installed!")
            print(f"\n{C_INFO}Installation options:{C_RESET}")
            print(f"  1. sudo apt update && sudo apt install exploitdb")
            print(f"  2. Or download manually:")
            print(f"     git clone https://gitlab.com/exploit-database/exploitdb.git")
            print(f"     cd exploitdb")
            print(f"     ./searchsploit --update")
            pause()
            return
        
        print(f"{C_INFO}Search Examples:{C_RESET}")
        print(f"  • apache 2.4                    (specific version)")
        print(f"  • wordpress plugin              (CMS plugins)")
        print(f"  • windows smb                   (service)")
        print(f"  • drupal                        (CMS)")
        print(f"  • webmin                        (web panel)")
        print(f"  • android                       (mobile)")
        print()
        
        search_term = input(f"{C_INFO}Enter search term: {C_RESET}").strip()
        
        if not search_term:
            Logger.error("Search term required!")
            pause()
            return
        
        Logger.info(f"Searching for: {search_term}")
        print()
        
        cmd = f"searchsploit {search_term}"
        
        # Run search
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"exploitdb_search_{timestamp}.txt")
        
        try:
            process = subprocess.Popen(
                cmd,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )
            
            output_lines = []
            for line in process.stdout:
                print(line, end='')
                output_lines.append(line)
            
            process.wait()
            
            # Save results
            content = ReportWriter.create_report_header("Exploit-DB Search", search_term)
            content += f"Command: {cmd}\n\n"
            content += "=" * 80 + "\n"
            content += "RESULTS\n"
            content += "=" * 80 + "\n\n"
            content += ''.join(output_lines)
            
            with open(report_file, 'w') as f:
                f.write(content)
            
            print()
            Logger.success(f"Results saved: {report_file}")
            
        except Exception as e:
            Logger.error(f"Search failed: {e}")
        
        pause()
    
    def download_exploit(self):
        """Download exploit from Exploit-DB"""
        clear_screen()
        print(f"\n{C_TITLE}═══ DOWNLOAD EXPLOIT ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('searchsploit'):
            Logger.error("Searchsploit not installed!")
            Logger.info("First install exploitdb (option 5)")
            pause()
            return
        
        print(f"{C_INFO}How to find exploit ID:{C_RESET}")
        print(f"  1. Use option 5 to search exploits")
        print(f"  2. Find the exploit you want")
        print(f"  3. Copy the ID number from results")
        print(f"\n{C_INFO}Example:{C_RESET}")
        print(f"  Exploit ID: 12345")
        print()
        
        exploit_id = input(f"{C_INFO}Enter exploit ID: {C_RESET}").strip()
        
        if not exploit_id:
            Logger.error("Exploit ID required!")
            pause()
            return
        
        Logger.info(f"Downloading exploit: {exploit_id}")
        
        # Download to current directory first
        cmd = f"searchsploit -m {exploit_id}"
        
        returncode, stdout, stderr = CommandRunner.run(cmd, shell=True)
        
        if returncode == 0:
            Logger.success("Exploit downloaded!")
            print(f"{C_INFO}{stdout}{C_RESET}")
            
            # Try to find and move the downloaded file
            moved = False
            for file in os.listdir('.'):
                if exploit_id in file or file.endswith(('.py', '.sh', '.rb', '.txt')):
                    try:
                        new_path = os.path.join(self.exploits_dir, file)
                        if os.path.exists(file):
                            os.rename(file, new_path)
                            Logger.info(f"Moved to: {new_path}")
                            moved = True
                            break
                    except Exception as e:
                        Logger.warning(f"Could not move file: {e}")
            
            if not moved:
                Logger.info(f"File may be in current directory")
                Logger.info(f"Move it manually to: {self.exploits_dir}")
        else:
            Logger.error("Download failed!")
            if stderr:
                print(f"{C_ERR}{stderr}{C_RESET}")
        
        pause()
    
    def buffer_overflow_helper(self):
        """Buffer overflow exploitation helper"""
        clear_screen()
        print(f"\n{C_TITLE}═══ BUFFER OVERFLOW HELPER ═══{C_RESET}\n")
        
        print(f"{C_INFO}Buffer Overflow Tools:{C_RESET}")
        print(f"  [1] Pattern Create      (Find offset)")
        print(f"  [2] Pattern Offset      (Calculate offset)")
        print(f"  [3] Generate Bad Chars  (Find bad characters)")
        print(f"  [4] Generate NOP Sled   (\\x90 padding)")
        print(f"  [5] JMP ESP Info        (Return address)")
        print()
        
        choice = input(f"{C_INFO}Select tool [1-5]: {C_RESET}").strip()
        
        if choice == '1':
            self._pattern_create()
        elif choice == '2':
            self._pattern_offset()
        elif choice == '3':
            self._generate_badchars()
        elif choice == '4':
            self._generate_nopsled()
        elif choice == '5':
            self._calculate_jmp_esp()
        else:
            Logger.error("Invalid choice!")
        
        pause()
    
    def _pattern_create(self):
        """Create pattern for buffer overflow"""
        print(f"\n{C_INFO}Pattern Create{C_RESET}")
        print(f"{C_WARN}Creates unique pattern to find offset{C_RESET}\n")
        
        length = input(f"{C_INFO}Enter pattern length [3000]: {C_RESET}").strip() or "3000"
        
        if not length.isdigit():
            Logger.error("Invalid length!")
            return
        
        length = int(length)
        
        # Use metasploit's pattern_create if available
        if CommandRunner.check_tool('msf-pattern_create'):
            cmd = f"msf-pattern_create -l {length}"
            returncode, stdout, stderr = CommandRunner.run(cmd, shell=True)
            if returncode == 0:
                pattern = stdout.strip()
                print(f"\n{C_OK}Pattern:{C_RESET}")
                print(pattern)
                
                # Save to file
                timestamp = ReportWriter.get_timestamp()
                pattern_file = os.path.join(self.reports_dir, f"pattern_{length}_{timestamp}.txt")
                with open(pattern_file, 'w') as f:
                    f.write(pattern)
                
                Logger.info(f"Saved: {pattern_file}")
                return
        
        # Simple pattern generator fallback
        Logger.warning("Using simple pattern generator (install metasploit for better results)")
        pattern = ""
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        
        for i in range(length):
            pattern += chars[i % len(chars)]
        
        print(f"\n{C_OK}Pattern:{C_RESET}")
        print(pattern[:200] + "..." if len(pattern) > 200 else pattern)
        
        # Save to file
        timestamp = ReportWriter.get_timestamp()
        pattern_file = os.path.join(self.reports_dir, f"pattern_{length}_{timestamp}.txt")
        with open(pattern_file, 'w') as f:
            f.write(pattern)
        
        Logger.info(f"Saved: {pattern_file}")
    
    def _pattern_offset(self):
        """Find offset in pattern"""
        print(f"\n{C_INFO}Pattern Offset{C_RESET}")
        print(f"{C_WARN}Finds offset of EIP/RIP value in pattern{C_RESET}\n")
        
        value = input(f"{C_INFO}Enter value (hex, e.g., 0x41424344): {C_RESET}").strip()
        
        if not value:
            Logger.error("Value required!")
            return
        
        # Remove 0x prefix if present
        value = value.replace('0x', '').replace('\\x', '')
        
        if CommandRunner.check_tool('msf-pattern_offset'):
            cmd = f"msf-pattern_offset -q {value}"
            returncode, stdout, stderr = CommandRunner.run(cmd, shell=True)
            if returncode == 0:
                print(f"\n{C_OK}Result:{C_RESET}")
                print(stdout)
            else:
                Logger.error("Offset calculation failed")
        else:
            Logger.warning("Install Metasploit for pattern_offset")
            print(f"{C_INFO}Manual command: msf-pattern_offset -q {value}{C_RESET}")
    
    def _generate_badchars(self):
        """Generate bad characters list"""
        print(f"\n{C_INFO}Bad Characters Generator{C_RESET}")
        print(f"{C_WARN}Generates list of all possible bytes to test{C_RESET}\n")
        
        print(f"{C_OK}Full Bad Characters (0x01-0xFF):{C_RESET}")
        
        # Hex format
        badchars_hex = ""
        for i in range(1, 256):
            badchars_hex += f"\\x{i:02x}"
            if i % 16 == 0:
                badchars_hex += "\n"
        
        print(badchars_hex)
        
        # Python format
        print(f"\n{C_OK}Python format:{C_RESET}")
        python_badchars = 'badchars = (\n'
        for i in range(1, 256):
            if i % 16 == 1:
                python_badchars += '    "'
            python_badchars += f"\\x{i:02x}"
            if i % 16 == 0:
                python_badchars += '"\n'
        python_badchars += ')'
        print(python_badchars)
        
        # C format
        print(f"\n{C_OK}C format:{C_RESET}")
        print('unsigned char badchars[] = ')
        for i in range(1, 256, 16):
            line = '    "'
            for j in range(i, min(i+16, 256)):
                line += f"\\x{j:02x}"
            line += '"'
            print(line)
        print(';')
        
        timestamp = ReportWriter.get_timestamp()
        badchars_file = os.path.join(self.reports_dir, f"badchars_{timestamp}.txt")
        with open(badchars_file, 'w') as f:
            f.write("Bad Characters\n")
            f.write("=" * 80 + "\n\n")
            f.write("Hex format:\n")
            f.write(badchars_hex)
            f.write("\n\nPython format:\n")
            f.write(python_badchars)
        
        Logger.info(f"Saved: {badchars_file}")
    
    def _generate_nopsled(self):
        """Generate NOP sled"""
        print(f"\n{C_INFO}NOP Sled Generator{C_RESET}")
        print(f"{C_WARN}Generates padding before shellcode{C_RESET}\n")
        
        length = input(f"{C_INFO}Enter NOP sled length [16]: {C_RESET}").strip() or "16"
        
        if not length.isdigit():
            Logger.error("Invalid length!")
            return
        
        length = int(length)
        
        print(f"\n{C_OK}NOP Sled (\\x90):{C_RESET}")
        print("\\x90" * length)
        
        print(f"\n{C_OK}Python format:{C_RESET}")
        print(f'nopsled = b"\\x90" * {length}')
        
        print(f"\n{C_OK}C format:{C_RESET}")
        nops = '"'
        for i in range(length):
            nops += "\\x90"
            if (i + 1) % 16 == 0 and i < length - 1:
                nops += '"\n"'
        nops += '"'
        print(nops)
    
    def _calculate_jmp_esp(self):
        """Calculate JMP ESP address"""
        print(f"\n{C_INFO}JMP ESP Information{C_RESET}")
        print(f"{C_WARN}Return address to jump to stack{C_RESET}\n")
        
        Logger.info("Common JMP ESP opcodes:")
        print(f"{C_OK}  x86: \\xFF\\xE4{C_RESET}")
        print(f"{C_OK}  x64: \\xFF\\xE4{C_RESET}")
        
        print(f"\n{C_INFO}Finding JMP ESP address:{C_RESET}")
        print("  1. Using Immunity Debugger + mona.py:")
        print("     !mona jmp -r esp -cpb '\\x00\\x0a\\x0d'")
        print()
        print("  2. Using msf-nasm_shell:")
        print("     $ msf-nasm_shell")
        print("     nasm > jmp esp")
        print("     FFE4")
        print()
        print("  3. Using objdump:")
        print("     objdump -D binary | grep 'ff e4'")
        
        print(f"\n{C_INFO}Example usage:{C_RESET}")
        print("  If JMP ESP is at 0x625011AF:")
        print("  eip = b'\\xAF\\x11\\x50\\x62'  # Little-endian")
    
    def _run_and_save(self, cmd, report_file, exploit_path, target):
        """Run command and save output"""
        try:
            # Create report header
            header = ReportWriter.create_report_header("Custom Exploit Execution", target or "N/A")
            
            Logger.info("Running exploit...")
            print(f"{C_OK}{'=' * 80}{C_RESET}\n")
            
            process = subprocess.Popen(
                cmd,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )
            
            output_lines = []
            for line in process.stdout:
                print(line, end='')
                output_lines.append(line)
            
            process.wait()
            
            print(f"\n{C_OK}{'=' * 80}{C_RESET}\n")
            
            # Save to file
            with open(report_file, 'w') as f:
                f.write(header)
                f.write(f"Exploit: {exploit_path}\n")
                if target:
                    f.write(f"Target: {target}\n")
                f.write(f"Command: {cmd}\n")
                f.write(f"Return Code: {process.returncode}\n\n")
                f.write("=" * 80 + "\n")
                f.write("OUTPUT\n")
                f.write("=" * 80 + "\n\n")
                f.writelines(output_lines)
            
            Logger.success(f"Report saved: {report_file}")
            
            if process.returncode != 0:
                Logger.warning(f"Exploit exited with code: {process.returncode}")
            
        except KeyboardInterrupt:
            Logger.warning("Exploit interrupted by user")
        except Exception as e:
            Logger.error(f"Error running exploit: {e}")

if __name__ == "__main__":
    runner = CustomExploitRunner()
    runner.run()