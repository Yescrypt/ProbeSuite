#!/usr/bin/env python3
# app/vulnerability/web_scanner.py - Web Vulnerability Scanner

import requests
import sys
import os
from urllib.parse import urljoin, urlparse, parse_qs
from datetime import datetime

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, BASE_DIR)

from config import C_OK, C_WARN, C_ERR, C_RESET, C_INFO, C_TITLE, REQUEST_TIMEOUT, HEADERS
from utils import Logger, pause, clear_screen, InputValidator, ReportWriter

class WebVulnScanner:
    def __init__(self):
        self.target = None
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update(HEADERS)
        
        # Basic payloads
        self.sqli_payloads = ["'", "1' OR '1'='1", "admin'--", "' OR 1=1--"]
        self.xss_payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>"]
        self.traversal_payloads = ["../", "../../etc/passwd", "..\\..\\windows\\system32\\"]
    
    def run(self):
        """Main scanner"""
        clear_screen()
        print(f"\n{C_TITLE}╔══════════════════════════════════════════╗")
        print(f"║       WEB VULNERABILITY SCANNER          ║")
        print(f"╚══════════════════════════════════════════╝{C_RESET}\n")
        
        self.target = InputValidator.get_url()
        if not self.target:
            return
        
        Logger.info(f"Target: {self.target}")
        Logger.warning("Starting comprehensive scan...")
        print()
        
        # Run scans
        self.check_security_headers()
        self.check_http_methods()
        self.basic_sqli_test()
        self.basic_xss_test()
        self.directory_traversal_test()
        self.check_admin_panels()
        
        # Results
        self.display_results()
        self.save_report()
        
        pause()
    
    def check_security_headers(self):
        """Check security headers"""
        Logger.info("Checking security headers...")
        
        try:
            response = self.session.get(self.target, timeout=REQUEST_TIMEOUT, verify=False)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection',
                'X-Content-Type-Options': 'MIME type sniffing protection',
                'Strict-Transport-Security': 'HTTPS enforcement',
                'Content-Security-Policy': 'XSS/injection protection',
                'X-XSS-Protection': 'XSS filter',
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vuln = {
                        'type': 'Missing Security Header',
                        'severity': 'Medium',
                        'header': header,
                        'description': description
                    }
                    self.vulnerabilities.append(vuln)
                    Logger.warning(f"Missing: {header} ({description})")
            
            Logger.success("Security headers check complete")
        except Exception as e:
            Logger.error(f"Header check failed: {e}")
    
    def check_http_methods(self):
        """Check allowed HTTP methods"""
        Logger.info("Checking HTTP methods...")
        
        try:
            response = self.session.options(self.target, timeout=REQUEST_TIMEOUT, verify=False)
            allowed = response.headers.get('Allow', '')
            
            dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'CONNECT']
            found_dangerous = [m for m in dangerous_methods if m in allowed.upper()]
            
            if found_dangerous:
                vuln = {
                    'type': 'Dangerous HTTP Methods',
                    'severity': 'High',
                    'methods': found_dangerous,
                    'description': f"Dangerous methods enabled: {', '.join(found_dangerous)}"
                }
                self.vulnerabilities.append(vuln)
                Logger.warning(f"Dangerous methods: {', '.join(found_dangerous)}")
            else:
                Logger.success("No dangerous HTTP methods found")
        except Exception as e:
            Logger.error(f"HTTP methods check failed: {e}")
    
    def basic_sqli_test(self):
        """Basic SQL Injection test"""
        Logger.info("Testing for SQL Injection...")
        
        try:
            parsed = urlparse(self.target)
            params = parse_qs(parsed.query)
            
            if not params:
                Logger.info("No URL parameters found, testing base URL...")
                # Test base URL with payloads
                for payload in self.sqli_payloads[:3]:
                    test_url = f"{self.target}{'&' if '?' in self.target else '?'}test={payload}"
                    try:
                        response = self.session.get(test_url, timeout=REQUEST_TIMEOUT, verify=False)
                        sql_errors = ['sql syntax', 'mysql', 'postgresql', 'oracle', 
                                     'sqlite', 'syntax error', 'database error']
                        
                        if any(error in response.text.lower() for error in sql_errors):
                            vuln = {
                                'type': 'SQL Injection',
                                'severity': 'Critical',
                                'parameter': 'test',
                                'payload': payload,
                                'description': f'Possible SQLi in base URL'
                            }
                            self.vulnerabilities.append(vuln)
                            Logger.warning(f"Possible SQLi found in base URL")
                            break
                    except:
                        continue
                Logger.success("SQL Injection test complete")
                return
            
            for param in params.keys():
                for payload in self.sqli_payloads:
                    test_url = self.target.replace(f"{param}={params[param][0]}", 
                                                   f"{param}={payload}")
                    try:
                        response = self.session.get(test_url, timeout=REQUEST_TIMEOUT, verify=False)
                        
                        sql_errors = ['sql syntax', 'mysql', 'postgresql', 'oracle', 
                                     'sqlite', 'syntax error', 'database error']
                        
                        if any(error in response.text.lower() for error in sql_errors):
                            vuln = {
                                'type': 'SQL Injection',
                                'severity': 'Critical',
                                'parameter': param,
                                'payload': payload,
                                'description': f'Possible SQLi in parameter: {param}'
                            }
                            self.vulnerabilities.append(vuln)
                            Logger.warning(f"Possible SQLi found in: {param}")
                            break
                    except:
                        continue
            
            Logger.success("SQL Injection test complete")
        except Exception as e:
            Logger.error(f"SQLi test failed: {e}")
    
    def basic_xss_test(self):
        """Basic XSS test"""
        Logger.info("Testing for XSS vulnerabilities...")
        
        try:
            parsed = urlparse(self.target)
            params = parse_qs(parsed.query)
            
            if not params:
                Logger.info("No URL parameters found, testing base URL...")
                # Test base URL
                for payload in self.xss_payloads[:3]:
                    test_url = f"{self.target}{'&' if '?' in self.target else '?'}test={payload}"
                    try:
                        response = self.session.get(test_url, timeout=REQUEST_TIMEOUT, verify=False)
                        
                        if payload in response.text:
                            vuln = {
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'High',
                                'parameter': 'test',
                                'payload': payload,
                                'description': f'Possible XSS in base URL'
                            }
                            self.vulnerabilities.append(vuln)
                            Logger.warning(f"Possible XSS found in base URL")
                            break
                    except:
                        continue
                Logger.success("XSS test complete")
                return
            
            for param in params.keys():
                for payload in self.xss_payloads:
                    test_url = self.target.replace(f"{param}={params[param][0]}", 
                                                   f"{param}={payload}")
                    try:
                        response = self.session.get(test_url, timeout=REQUEST_TIMEOUT, verify=False)
                        
                        if payload in response.text:
                            vuln = {
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'High',
                                'parameter': param,
                                'payload': payload,
                                'description': f'Possible XSS in parameter: {param}'
                            }
                            self.vulnerabilities.append(vuln)
                            Logger.warning(f"Possible XSS found in: {param}")
                            break
                    except:
                        continue
            
            Logger.success("XSS test complete")
        except Exception as e:
            Logger.error(f"XSS test failed: {e}")
    
    def directory_traversal_test(self):
        """Directory traversal test"""
        Logger.info("Testing for directory traversal...")
        
        try:
            for payload in self.traversal_payloads:
                test_url = urljoin(self.target, payload)
                try:
                    response = self.session.get(test_url, timeout=REQUEST_TIMEOUT, verify=False)
                    
                    indicators = ['root:x:', '[boot loader]', 'Windows', '/bin/bash']
                    
                    if any(ind in response.text for ind in indicators):
                        vuln = {
                            'type': 'Directory Traversal',
                            'severity': 'Critical',
                            'payload': payload,
                            'description': 'Possible directory traversal vulnerability'
                        }
                        self.vulnerabilities.append(vuln)
                        Logger.warning(f"Possible directory traversal: {payload}")
                        break
                except:
                    continue
            
            Logger.success("Directory traversal test complete")
        except Exception as e:
            Logger.error(f"Traversal test failed: {e}")
    
    def check_admin_panels(self):
        """Check for exposed admin panels"""
        Logger.info("Checking for admin panels...")
        
        admin_paths = [
            '/admin', '/administrator', '/admin.php', '/login', 
            '/wp-admin', '/cpanel', '/phpmyadmin', '/admin/login'
        ]
        
        try:
            for path in admin_paths:
                test_url = urljoin(self.target, path)
                try:
                    response = self.session.get(test_url, timeout=5, verify=False)
                    
                    if response.status_code == 200:
                        vuln = {
                            'type': 'Exposed Admin Panel',
                            'severity': 'Medium',
                            'path': path,
                            'description': f'Admin panel found at: {path}'
                        }
                        self.vulnerabilities.append(vuln)
                        Logger.warning(f"Admin panel found: {path}")
                except:
                    continue
            
            Logger.success("Admin panel check complete")
        except Exception as e:
            Logger.error(f"Admin panel check failed: {e}")
    
    def display_results(self):
        """Display scan results"""
        print(f"\n{C_TITLE}{'='*60}")
        print(f"SCAN RESULTS")
        print(f"{'='*60}{C_RESET}\n")
        
        if not self.vulnerabilities:
            Logger.success("No vulnerabilities found!")
            return
        
        critical = [v for v in self.vulnerabilities if v.get('severity') == 'Critical']
        high = [v for v in self.vulnerabilities if v.get('severity') == 'High']
        medium = [v for v in self.vulnerabilities if v.get('severity') == 'Medium']
        
        print(f"{C_ERR}Critical: {len(critical)}{C_RESET}")
        print(f"{C_WARN}High: {len(high)}{C_RESET}")
        print(f"{C_INFO}Medium: {len(medium)}{C_RESET}")
        print()
        
        for vuln in self.vulnerabilities:
            severity_color = C_ERR if vuln['severity'] == 'Critical' else \
                           C_WARN if vuln['severity'] == 'High' else C_INFO
            
            print(f"{severity_color}[{vuln['severity']}] {vuln['type']}{C_RESET}")
            print(f"  Description: {vuln['description']}")
            print()
    
    def save_report(self):
        """Save scan report"""
        if not self.vulnerabilities:
            return
        
        timestamp = ReportWriter.get_timestamp()
        filename = f"web_vuln_scan_{timestamp}"
        
        report_data = {
            'target': self.target,
            'scan_date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'total_vulnerabilities': len(self.vulnerabilities),
            'vulnerabilities': self.vulnerabilities
        }
        
        # Save JSON
        ReportWriter.save_json(filename, report_data, subfolder='vulnerability/web_scanner')
        
        # Save TXT
        txt_content = ReportWriter.create_report_header("WEB VULNERABILITY SCAN REPORT", self.target)
        txt_content += f"Total Vulnerabilities: {len(self.vulnerabilities)}\n\n"
        
        for i, vuln in enumerate(self.vulnerabilities, 1):
            txt_content += f"[{i}] {vuln['type']} - {vuln['severity']}\n"
            txt_content += f"Description: {vuln['description']}\n"
            if 'parameter' in vuln:
                txt_content += f"Parameter: {vuln['parameter']}\n"
            if 'payload' in vuln:
                txt_content += f"Payload: {vuln['payload']}\n"
            txt_content += "\n"
        
        ReportWriter.save_txt(filename, txt_content, subfolder='vulnerability/web_scanner')

if __name__ == "__main__":
    scanner = WebVulnScanner()
    scanner.run()