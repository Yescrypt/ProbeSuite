#!/usr/bin/env python3
# app/vulnerability/ssl_tls_analyzer.py - SSL/TLS Security Analyzer

import ssl
import socket
import sys
import os
from datetime import datetime
from urllib.parse import urlparse

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, BASE_DIR)

from config import C_OK, C_WARN, C_ERR, C_RESET, C_INFO, C_TITLE
from utils import Logger, pause, clear_screen, InputValidator, ReportWriter, URLValidator

class SSLAnalyzer:
    def __init__(self):
        self.target = None
        self.hostname = None
        self.port = 443
        self.findings = []
        self.cert_info = {}
    
    def run(self):
        """Main SSL/TLS analyzer"""
        clear_screen()
        print(f"\n{C_TITLE}╔══════════════════════════════════════════╗")
        print(f"║       SSL/TLS SECURITY ANALYZER          ║")
        print(f"╚══════════════════════════════════════════╝{C_RESET}\n")
        
        self.target = InputValidator.get_url()
        if not self.target:
            return
        
        # Extract hostname
        self.hostname = URLValidator.extract_domain(self.target)
        
        Logger.info(f"Target: {self.hostname}:{self.port}")
        Logger.warning("Starting SSL/TLS analysis...")
        print()
        
        # Run analysis
        self.check_ssl_connection()
        self.check_certificate()
        self.check_protocols()
        self.check_cipher_suites()
        self.check_vulnerabilities()
        
        # Results
        self.display_results()
        self.save_report()
        
        pause()
    
    def check_ssl_connection(self):
        """Check if SSL/TLS is enabled"""
        Logger.info("Checking SSL/TLS connection...")
        
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.hostname, self.port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=self.hostname) as ssock:
                    Logger.success(f"SSL/TLS connection established")
                    Logger.info(f"Protocol: {ssock.version()}")
        except ssl.SSLError as e:
            self.findings.append({
                'type': 'SSL/TLS Error',
                'severity': 'High',
                'description': f'SSL/TLS connection failed: {str(e)}'
            })
            Logger.error(f"SSL/TLS connection failed: {e}")
        except Exception as e:
            Logger.error(f"Connection failed: {e}")
    
    def check_certificate(self):
        """Check SSL certificate details"""
        Logger.info("Analyzing SSL certificate...")
        
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.hostname, self.port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=self.hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Extract certificate info
                    self.cert_info = {
                        'subject': dict(x[0] for x in cert['subject']),
                        'issuer': dict(x[0] for x in cert['issuer']),
                        'version': cert['version'],
                        'serialNumber': cert['serialNumber'],
                        'notBefore': cert['notBefore'],
                        'notAfter': cert['notAfter'],
                    }
                    
                    # Check expiry
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_left = (not_after - datetime.now()).days
                    
                    Logger.success(f"Certificate valid until: {cert['notAfter']}")
                    Logger.info(f"Days remaining: {days_left}")
                    
                    if days_left < 30:
                        self.findings.append({
                            'type': 'Certificate Expiring Soon',
                            'severity': 'Medium',
                            'days_left': days_left,
                            'description': f'Certificate expires in {days_left} days'
                        })
                        Logger.warning(f"Certificate expires in {days_left} days!")
                    
                    # Check subject
                    subject_cn = self.cert_info['subject'].get('commonName', 'N/A')
                    Logger.info(f"Common Name: {subject_cn}")
                    
                    # Check issuer
                    issuer_cn = self.cert_info['issuer'].get('commonName', 'N/A')
                    Logger.info(f"Issuer: {issuer_cn}")
                    
                    # Check for self-signed
                    if self.cert_info['subject'] == self.cert_info['issuer']:
                        self.findings.append({
                            'type': 'Self-Signed Certificate',
                            'severity': 'Medium',
                            'description': 'Certificate is self-signed'
                        })
                        Logger.warning("Certificate is self-signed!")
                    
        except ssl.SSLError as e:
            Logger.error(f"Certificate check failed: {e}")
        except Exception as e:
            Logger.error(f"Error checking certificate: {e}")
    
    def check_protocols(self):
        """Check supported SSL/TLS protocols"""
        Logger.info("Checking SSL/TLS protocol versions...")
        
        protocols = {
            'SSLv2': ssl.PROTOCOL_SSLv23,  # Deprecated
            'SSLv3': ssl.PROTOCOL_SSLv23,  # Deprecated
            'TLSv1.0': ssl.PROTOCOL_TLSv1 if hasattr(ssl, 'PROTOCOL_TLSv1') else None,
            'TLSv1.1': ssl.PROTOCOL_TLSv1_1 if hasattr(ssl, 'PROTOCOL_TLSv1_1') else None,
            'TLSv1.2': ssl.PROTOCOL_TLSv1_2 if hasattr(ssl, 'PROTOCOL_TLSv1_2') else None,
            'TLSv1.3': ssl.PROTOCOL_TLS if hasattr(ssl, 'PROTOCOL_TLS') else None,
        }
        
        vulnerable_protocols = ['SSLv2', 'SSLv3', 'TLSv1.0']
        
        for proto_name, proto in protocols.items():
            if proto is None:
                continue
            
            try:
                context = ssl.SSLContext(proto)
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                
                with socket.create_connection((self.hostname, self.port), timeout=5) as sock:
                    with context.wrap_socket(sock) as ssock:
                        Logger.success(f"{proto_name} supported")
                        
                        if proto_name in vulnerable_protocols:
                            self.findings.append({
                                'type': 'Weak Protocol',
                                'severity': 'High',
                                'protocol': proto_name,
                                'description': f'Vulnerable protocol {proto_name} is enabled'
                            })
                            Logger.warning(f"{proto_name} is deprecated and vulnerable!")
            except:
                Logger.info(f"{proto_name} not supported")
    
    def check_cipher_suites(self):
        """Check cipher suites"""
        Logger.info("Checking cipher suites...")
        
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.hostname, self.port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=self.hostname) as ssock:
                    cipher = ssock.cipher()
                    Logger.info(f"Cipher: {cipher[0]}")
                    Logger.info(f"Protocol: {cipher[1]}")
                    Logger.info(f"Bits: {cipher[2]}")
                    
                    # Check for weak ciphers
                    weak_ciphers = ['DES', 'RC4', 'MD5', 'NULL', 'EXPORT', 'anon']
                    cipher_name = cipher[0]
                    
                    if any(weak in cipher_name for weak in weak_ciphers):
                        self.findings.append({
                            'type': 'Weak Cipher',
                            'severity': 'High',
                            'cipher': cipher_name,
                            'description': f'Weak cipher suite in use: {cipher_name}'
                        })
                        Logger.warning(f"Weak cipher detected: {cipher_name}")
        except Exception as e:
            Logger.error(f"Cipher check failed: {e}")
    
    def check_vulnerabilities(self):
        """Check for known SSL/TLS vulnerabilities"""
        Logger.info("Checking for known vulnerabilities...")
        
        # Heartbleed check (CVE-2014-0160)
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((self.hostname, self.port), timeout=5) as sock:
                with context.wrap_socket(sock) as ssock:
                    # Simple check - if TLS 1.0 works, might be vulnerable
                    Logger.info("TLS 1.0 supported - potential Heartbleed risk")
        except:
            Logger.info("TLS 1.0 not supported - Heartbleed unlikely")
        
        # POODLE check (SSLv3)
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((self.hostname, self.port), timeout=5) as sock:
                with context.wrap_socket(sock) as ssock:
                    if ssock.version() == 'SSLv3':
                        self.findings.append({
                            'type': 'POODLE Vulnerability',
                            'severity': 'High',
                            'description': 'SSLv3 is vulnerable to POODLE attack'
                        })
                        Logger.warning("POODLE vulnerability detected (SSLv3 enabled)!")
        except:
            Logger.info("SSLv3 not supported - POODLE not vulnerable")
    
    def display_results(self):
        """Display analysis results"""
        print(f"\n{C_TITLE}{'='*60}")
        print(f"SSL/TLS ANALYSIS RESULTS")
        print(f"{'='*60}{C_RESET}\n")
        
        # Certificate info
        if self.cert_info:
            print(f"{C_INFO}Certificate Information:{C_RESET}")
            print(f"  Subject: {self.cert_info['subject'].get('commonName', 'N/A')}")
            print(f"  Issuer: {self.cert_info['issuer'].get('commonName', 'N/A')}")
            print(f"  Valid From: {self.cert_info['notBefore']}")
            print(f"  Valid Until: {self.cert_info['notAfter']}")
            print()
        
        # Findings
        if not self.findings:
            Logger.success("No security issues found!")
            return
        
        print(f"{C_WARN}Security Findings: {len(self.findings)}{C_RESET}\n")
        
        for i, finding in enumerate(self.findings, 1):
            severity_color = C_ERR if finding['severity'] == 'High' else \
                           C_WARN if finding['severity'] == 'Medium' else C_INFO
            
            print(f"{severity_color}[{i}] {finding['type']} ({finding['severity']}){C_RESET}")
            print(f"  {finding['description']}")
            print()
    
    def save_report(self):
        """Save analysis report"""
        timestamp = ReportWriter.get_timestamp()
        filename = f"ssl_analysis_{timestamp}"
        
        report_data = {
            'target': f"{self.hostname}:{self.port}",
            'scan_date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'certificate': self.cert_info,
            'findings': self.findings,
            'total_issues': len(self.findings)
        }
        
        # Save JSON
        ReportWriter.save_json(filename, report_data, subfolder='vulnerability/ssl_analyzer')
        
        # Save TXT
        txt_content = ReportWriter.create_report_header("SSL/TLS ANALYSIS REPORT", f"{self.hostname}:{self.port}")
        
        if self.cert_info:
            txt_content += "CERTIFICATE INFORMATION\n"
            txt_content += "=" * 80 + "\n"
            txt_content += f"Subject: {self.cert_info['subject'].get('commonName', 'N/A')}\n"
            txt_content += f"Issuer: {self.cert_info['issuer'].get('commonName', 'N/A')}\n"
            txt_content += f"Valid From: {self.cert_info['notBefore']}\n"
            txt_content += f"Valid Until: {self.cert_info['notAfter']}\n"
            txt_content += f"Serial Number: {self.cert_info['serialNumber']}\n\n"
        
        if self.findings:
            txt_content += f"SECURITY FINDINGS ({len(self.findings)})\n"
            txt_content += "=" * 80 + "\n\n"
            
            for i, finding in enumerate(self.findings, 1):
                txt_content += f"[{i}] {finding['type']} - {finding['severity']}\n"
                txt_content += f"Description: {finding['description']}\n"
                txt_content += "\n"
        else:
            txt_content += "No security issues found!\n"
        
        ReportWriter.save_txt(filename, txt_content, subfolder='vulnerability/ssl_analyzer')

if __name__ == "__main__":
    analyzer = SSLAnalyzer()
    analyzer.run()